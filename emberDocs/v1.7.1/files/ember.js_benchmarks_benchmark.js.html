<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ember.js/benchmarks/benchmark.js - The Ember API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The Ember API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/A Suite can be used to define a reusable set of unit tests that can be
                applied to any object.  Suites are most useful for defining tests that
                work against a mixin or plugin API.  Developers implementing objects that
                use the mixin or support the API can then run these tests against their
                own code to verify compliance.
                
                To define a suite, you need to define the tests themselves as well as a
                callback API implementors can use to tie your tests to thier specific class.
                
                ## Defining a Callback API
                
                To define the callback API, just extend this class and add your properties
                or methods that must be provided.  Use Ember.required() placeholders for
                any properties that implementors must define themselves.
                
                ## Defining Unit Tests
                
                To add unit tests, use the suite.module() or suite.test() methods instead
                of a regular module() or test() method when defining your tests.  This will
                add the tests to the suite.
                
                ## Using a Suite
                
                To use a Suite to test your own objects, extend the suite subclass and
                define any required methods.  Then call run() on the new subclass.  This
                will create an instance of your class and then defining the unit tests..html">A Suite can be used to define a reusable set of unit tests that can be
                applied to any object.  Suites are most useful for defining tests that
                work against a mixin or plugin API.  Developers implementing objects that
                use the mixin or support the API can then run these tests against their
                own code to verify compliance.
                
                To define a suite, you need to define the tests themselves as well as a
                callback API implementors can use to tie your tests to thier specific class.
                
                ## Defining a Callback API
                
                To define the callback API, just extend this class and add your properties
                or methods that must be provided.  Use Ember.required() placeholders for
                any properties that implementors must define themselves.
                
                ## Defining Unit Tests
                
                To add unit tests, use the suite.module() or suite.test() methods instead
                of a regular module() or test() method when defining your tests.  This will
                add the tests to the suite.
                
                ## Using a Suite
                
                To use a Suite to test your own objects, extend the suite subclass and
                define any required methods.  Then call run() on the new subclass.  This
                will create an instance of your class and then defining the unit tests.</a></li>
                                <li><a href="../classes/Ember.html">Ember</a></li>
                                <li><a href="../classes/Ember._HandlebarsBoundView.html">Ember._HandlebarsBoundView</a></li>
                                <li><a href="../classes/Ember._Metamorph.html">Ember._Metamorph</a></li>
                                <li><a href="../classes/Ember._MetamorphView.html">Ember._MetamorphView</a></li>
                                <li><a href="../classes/Ember._SimpleMetamorphView.html">Ember._SimpleMetamorphView</a></li>
                                <li><a href="../classes/Ember.ActionHandler.html">Ember.ActionHandler</a></li>
                                <li><a href="../classes/Ember.Application.html">Ember.Application</a></li>
                                <li><a href="../classes/Ember.Array.html">Ember.Array</a></li>
                                <li><a href="../classes/Ember.ArrayController.html">Ember.ArrayController</a></li>
                                <li><a href="../classes/Ember.ArrayProxy.html">Ember.ArrayProxy</a></li>
                                <li><a href="../classes/Ember.AutoLocation.html">Ember.AutoLocation</a></li>
                                <li><a href="../classes/Ember.Binding.html">Ember.Binding</a></li>
                                <li><a href="../classes/Ember.Checkbox.html">Ember.Checkbox</a></li>
                                <li><a href="../classes/Ember.CollectionView.html">Ember.CollectionView</a></li>
                                <li><a href="../classes/Ember.Comparable.html">Ember.Comparable</a></li>
                                <li><a href="../classes/Ember.Component.html">Ember.Component</a></li>
                                <li><a href="../classes/Ember.ComponentTemplateDeprecation.html">Ember.ComponentTemplateDeprecation</a></li>
                                <li><a href="../classes/Ember.ComputedProperty.html">Ember.ComputedProperty</a></li>
                                <li><a href="../classes/Ember.ContainerDebugAdapter.html">Ember.ContainerDebugAdapter</a></li>
                                <li><a href="../classes/Ember.ContainerView.html">Ember.ContainerView</a></li>
                                <li><a href="../classes/Ember.Controller.html">Ember.Controller</a></li>
                                <li><a href="../classes/Ember.ControllerContentModelAliasDeprecation.html">Ember.ControllerContentModelAliasDeprecation</a></li>
                                <li><a href="../classes/Ember.ControllerMixin.html">Ember.ControllerMixin</a></li>
                                <li><a href="../classes/Ember.Copyable.html">Ember.Copyable</a></li>
                                <li><a href="../classes/Ember.CoreObject.html">Ember.CoreObject</a></li>
                                <li><a href="../classes/Ember.CoreView.html">Ember.CoreView</a></li>
                                <li><a href="../classes/Ember.DAG.html">Ember.DAG</a></li>
                                <li><a href="../classes/Ember.DataAdapter.html">Ember.DataAdapter</a></li>
                                <li><a href="../classes/Ember.DefaultResolver.html">Ember.DefaultResolver</a></li>
                                <li><a href="../classes/Ember.Deferred.html">Ember.Deferred</a></li>
                                <li><a href="../classes/Ember.Descriptor.html">Ember.Descriptor</a></li>
                                <li><a href="../classes/Ember.EachProxy.html">Ember.EachProxy</a></li>
                                <li><a href="../classes/Ember.Enumerable.html">Ember.Enumerable</a></li>
                                <li><a href="../classes/Ember.EnumerableUtils.html">Ember.EnumerableUtils</a></li>
                                <li><a href="../classes/Ember.Error.html">Ember.Error</a></li>
                                <li><a href="../classes/Ember.EventDispatcher.html">Ember.EventDispatcher</a></li>
                                <li><a href="../classes/Ember.Evented.html">Ember.Evented</a></li>
                                <li><a href="../classes/Ember.FEATURES.html">Ember.FEATURES</a></li>
                                <li><a href="../classes/Ember.Freezable.html">Ember.Freezable</a></li>
                                <li><a href="../classes/Ember.Handlebars.html">Ember.Handlebars</a></li>
                                <li><a href="../classes/Ember.Handlebars.Compiler.html">Ember.Handlebars.Compiler</a></li>
                                <li><a href="../classes/Ember.Handlebars.helpers.html">Ember.Handlebars.helpers</a></li>
                                <li><a href="../classes/Ember.Handlebars.JavaScriptCompiler.html">Ember.Handlebars.JavaScriptCompiler</a></li>
                                <li><a href="../classes/Ember.HashLocation.html">Ember.HashLocation</a></li>
                                <li><a href="../classes/Ember.HistoryLocation.html">Ember.HistoryLocation</a></li>
                                <li><a href="../classes/Ember.Instrumentation.html">Ember.Instrumentation</a></li>
                                <li><a href="../classes/Ember.LinkView.html">Ember.LinkView</a></li>
                                <li><a href="../classes/Ember.Location.html">Ember.Location</a></li>
                                <li><a href="../classes/Ember.Logger.html">Ember.Logger</a></li>
                                <li><a href="../classes/Ember.Map.html">Ember.Map</a></li>
                                <li><a href="../classes/Ember.MapWithDefault.html">Ember.MapWithDefault</a></li>
                                <li><a href="../classes/Ember.Mixin.html">Ember.Mixin</a></li>
                                <li><a href="../classes/Ember.MutableArray.html">Ember.MutableArray</a></li>
                                <li><a href="../classes/Ember.MutableEnumerable.html">Ember.MutableEnumerable</a></li>
                                <li><a href="../classes/Ember.Namespace.html">Ember.Namespace</a></li>
                                <li><a href="../classes/Ember.NativeArray.html">Ember.NativeArray</a></li>
                                <li><a href="../classes/Ember.NoneLocation.html">Ember.NoneLocation</a></li>
                                <li><a href="../classes/Ember.Object.html">Ember.Object</a></li>
                                <li><a href="../classes/Ember.ObjectController.html">Ember.ObjectController</a></li>
                                <li><a href="../classes/Ember.ObjectProxy.html">Ember.ObjectProxy</a></li>
                                <li><a href="../classes/Ember.Observable.html">Ember.Observable</a></li>
                                <li><a href="../classes/Ember.OrderedSet.html">Ember.OrderedSet</a></li>
                                <li><a href="../classes/Ember.platform.html">Ember.platform</a></li>
                                <li><a href="../classes/Ember.PromiseProxyMixin.html">Ember.PromiseProxyMixin</a></li>
                                <li><a href="../classes/Ember.ReduceComputedProperty.html">Ember.ReduceComputedProperty</a></li>
                                <li><a href="../classes/Ember.RenderBuffer.html">Ember.RenderBuffer</a></li>
                                <li><a href="../classes/Ember.Route.html">Ember.Route</a></li>
                                <li><a href="../classes/Ember.Router.html">Ember.Router</a></li>
                                <li><a href="../classes/Ember.run.html">Ember.run</a></li>
                                <li><a href="../classes/Ember.Select.html">Ember.Select</a></li>
                                <li><a href="../classes/Ember.Set.html">Ember.Set</a></li>
                                <li><a href="../classes/Ember.SortableMixin.html">Ember.SortableMixin</a></li>
                                <li><a href="../classes/Ember.State.html">Ember.State</a></li>
                                <li><a href="../classes/Ember.StateManager.html">Ember.StateManager</a></li>
                                <li><a href="../classes/Ember.String.html">Ember.String</a></li>
                                <li><a href="../classes/Ember.SubArray.html">Ember.SubArray</a></li>
                                <li><a href="../classes/Ember.TargetActionSupport.html">Ember.TargetActionSupport</a></li>
                                <li><a href="../classes/Ember.Test.html">Ember.Test</a></li>
                                <li><a href="../classes/Ember.Test.Adapter.html">Ember.Test.Adapter</a></li>
                                <li><a href="../classes/Ember.Test.QUnitAdapter.html">Ember.Test.QUnitAdapter</a></li>
                                <li><a href="../classes/Ember.TextArea.html">Ember.TextArea</a></li>
                                <li><a href="../classes/Ember.TextField.html">Ember.TextField</a></li>
                                <li><a href="../classes/Ember.TextSupport.html">Ember.TextSupport</a></li>
                                <li><a href="../classes/Ember.TrackedArray.html">Ember.TrackedArray</a></li>
                                <li><a href="../classes/Ember.View.html">Ember.View</a></li>
                                <li><a href="../classes/Ember.ViewTargetActionSupport.html">Ember.ViewTargetActionSupport</a></li>
                                <li><a href="../classes/Function.html">Function</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ember.html">ember</a></li>
                                <li><a href="../modules/ember-application.html">ember-application</a></li>
                                <li><a href="../modules/ember-debug.html">ember-debug</a></li>
                                <li><a href="../modules/ember-extension-support.html">ember-extension-support</a></li>
                                <li><a href="../modules/ember-handlebars.html">ember-handlebars</a></li>
                                <li><a href="../modules/ember-handlebars-compiler.html">ember-handlebars-compiler</a></li>
                                <li><a href="../modules/ember-metal.html">ember-metal</a></li>
                                <li><a href="../modules/ember-routing.html">ember-routing</a></li>
                                <li><a href="../modules/ember-routing-handlebars.html">ember-routing-handlebars</a></li>
                                <li><a href="../modules/ember-runtime.html">ember-runtime</a></li>
                                <li><a href="../modules/ember-testing.html">ember-testing</a></li>
                                <li><a href="../modules/ember-views.html">ember-views</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ember.js/benchmarks/benchmark.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * Benchmark.js v1.0.0-pre &lt;http://benchmarkjs.com/&gt;
 * Copyright 2010-2012 Mathias Bynens &lt;http://mths.be/&gt;
 * Based on JSLitmus.js, copyright Robert Kieffer &lt;http://broofa.com/&gt;
 * Modified by John-David Dalton &lt;http://allyoucanleet.com/&gt;
 * Available under MIT license &lt;http://mths.be/mit&gt;
 */
;(function(window, undefined) {
  &#x27;use strict&#x27;;

  /** Used to assign each benchmark an incrimented id */
  var counter = 0;

  /** Detect DOM document object */
  var doc = isHostType(window, &#x27;document&#x27;) &amp;&amp; document;

  /** Detect free variable &#x60;define&#x60; */
  var freeDefine = typeof define == &#x27;function&#x27; &amp;&amp;
    typeof define.amd == &#x27;object&#x27; &amp;&amp; define.amd &amp;&amp; define;

  /** Detect free variable &#x60;exports&#x60; */
  var freeExports = typeof exports == &#x27;object&#x27; &amp;&amp; exports &amp;&amp;
    (typeof global == &#x27;object&#x27; &amp;&amp; global &amp;&amp; global == global.global &amp;&amp; (window = global), exports);

  /** Detect free variable &#x60;require&#x60; */
  var freeRequire = typeof require == &#x27;function&#x27; &amp;&amp; require;

  /** Used to crawl all properties regardless of enumerability */
  var getAllKeys = Object.getOwnPropertyNames;

  /** Used to get property descriptors */
  var getDescriptor = Object.getOwnPropertyDescriptor;

  /** Used in case an object doesn&#x27;t have its own method */
  var hasOwnProperty = {}.hasOwnProperty;

  /** Used to check if an object is extensible */
  var isExtensible = Object.isExtensible || function() { return true; };

  /** Used to access the browser&#x27;s high resolution timer */
  var perfObject = isHostType(window, &#x27;performance&#x27;) &amp;&amp; performance;

  /** Used to call the browser&#x27;s high resolution timer */
  var perfName = perfObject &amp;&amp; (
    perfObject.now &amp;&amp; &#x27;now&#x27; ||
    perfObject.mozNow &amp;&amp; &#x27;mozNow&#x27; ||
    perfObject.msNow &amp;&amp; &#x27;msNow&#x27; ||
    perfObject.oNow &amp;&amp; &#x27;oNow&#x27; ||
    perfObject.webkitNow &amp;&amp; &#x27;webkitNow&#x27;
  );

  /** Used to check if an own property is enumerable */
  var propertyIsEnumerable = {}.propertyIsEnumerable;

  /** Used to set property descriptors */
  var setDescriptor = Object.defineProperty;

  /** Used to resolve a value&#x27;s internal [[Class]] */
  var toString = {}.toString;

  /** Used to prevent a &#x60;removeChild&#x60; memory leak in IE &lt; 9 */
  var trash = doc &amp;&amp; doc.createElement(&#x27;div&#x27;);

  /** Used to integrity check compiled tests */
  var uid = &#x27;uid&#x27; + (+new Date);

  /** Used to avoid infinite recursion when methods call each other */
  var calledBy = {};

  /** Used to avoid hz of Infinity */
  var divisors = {
    &#x27;1&#x27;: 4096,
    &#x27;2&#x27;: 512,
    &#x27;3&#x27;: 64,
    &#x27;4&#x27;: 8,
    &#x27;5&#x27;: 0
  };

  /**
   * T-Distribution two-tailed critical values for 95% confidence
   * http://www.itl.nist.gov/div898/handbook/eda/section3/eda3672.htm
   */
  var tTable = {
    &#x27;1&#x27;:  12.706,&#x27;2&#x27;:  4.303, &#x27;3&#x27;:  3.182, &#x27;4&#x27;:  2.776, &#x27;5&#x27;:  2.571, &#x27;6&#x27;:  2.447,
    &#x27;7&#x27;:  2.365, &#x27;8&#x27;:  2.306, &#x27;9&#x27;:  2.262, &#x27;10&#x27;: 2.228, &#x27;11&#x27;: 2.201, &#x27;12&#x27;: 2.179,
    &#x27;13&#x27;: 2.16,  &#x27;14&#x27;: 2.145, &#x27;15&#x27;: 2.131, &#x27;16&#x27;: 2.12,  &#x27;17&#x27;: 2.11,  &#x27;18&#x27;: 2.101,
    &#x27;19&#x27;: 2.093, &#x27;20&#x27;: 2.086, &#x27;21&#x27;: 2.08,  &#x27;22&#x27;: 2.074, &#x27;23&#x27;: 2.069, &#x27;24&#x27;: 2.064,
    &#x27;25&#x27;: 2.06,  &#x27;26&#x27;: 2.056, &#x27;27&#x27;: 2.052, &#x27;28&#x27;: 2.048, &#x27;29&#x27;: 2.045, &#x27;30&#x27;: 2.042,
    &#x27;infinity&#x27;: 1.96
  };

  /**
   * Critical Mann-Whitney U-values for 95% confidence
   * http://www.saburchill.com/IBbiology/stats/003.html
   */
  var uTable = {
    &#x27;5&#x27;:  [0, 1, 2],
    &#x27;6&#x27;:  [1, 2, 3, 5],
    &#x27;7&#x27;:  [1, 3, 5, 6, 8],
    &#x27;8&#x27;:  [2, 4, 6, 8, 10, 13],
    &#x27;9&#x27;:  [2, 4, 7, 10, 12, 15, 17],
    &#x27;10&#x27;: [3, 5, 8, 11, 14, 17, 20, 23],
    &#x27;11&#x27;: [3, 6, 9, 13, 16, 19, 23, 26, 30],
    &#x27;12&#x27;: [4, 7, 11, 14, 18, 22, 26, 29, 33, 37],
    &#x27;13&#x27;: [4, 8, 12, 16, 20, 24, 28, 33, 37, 41, 45],
    &#x27;14&#x27;: [5, 9, 13, 17, 22, 26, 31, 36, 40, 45, 50, 55],
    &#x27;15&#x27;: [5, 10, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64],
    &#x27;16&#x27;: [6, 11, 15, 21, 26, 31, 37, 42, 47, 53, 59, 64, 70, 75],
    &#x27;17&#x27;: [6, 11, 17, 22, 28, 34, 39, 45, 51, 57, 63, 67, 75, 81, 87],
    &#x27;18&#x27;: [7, 12, 18, 24, 30, 36, 42, 48, 55, 61, 67, 74, 80, 86, 93, 99],
    &#x27;19&#x27;: [7, 13, 19, 25, 32, 38, 45, 52, 58, 65, 72, 78, 85, 92, 99, 106, 113],
    &#x27;20&#x27;: [8, 14, 20, 27, 34, 41, 48, 55, 62, 69, 76, 83, 90, 98, 105, 112, 119, 127],
    &#x27;21&#x27;: [8, 15, 22, 29, 36, 43, 50, 58, 65, 73, 80, 88, 96, 103, 111, 119, 126, 134, 142],
    &#x27;22&#x27;: [9, 16, 23, 30, 38, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125, 133, 141, 150, 158],
    &#x27;23&#x27;: [9, 17, 24, 32, 40, 48, 56, 64, 73, 81, 89, 98, 106, 115, 123, 132, 140, 149, 157, 166, 175],
    &#x27;24&#x27;: [10, 17, 25, 33, 42, 50, 59, 67, 76, 85, 94, 102, 111, 120, 129, 138, 147, 156, 165, 174, 183, 192],
    &#x27;25&#x27;: [10, 18, 27, 35, 44, 53, 62, 71, 80, 89, 98, 107, 117, 126, 135, 145, 154, 163, 173, 182, 192, 201, 211],
    &#x27;26&#x27;: [11, 19, 28, 37, 46, 55, 64, 74, 83, 93, 102, 112, 122, 132, 141, 151, 161, 171, 181, 191, 200, 210, 220, 230],
    &#x27;27&#x27;: [11, 20, 29, 38, 48, 57, 67, 77, 87, 97, 107, 118, 125, 138, 147, 158, 168, 178, 188, 199, 209, 219, 230, 240, 250],
    &#x27;28&#x27;: [12, 21, 30, 40, 50, 60, 70, 80, 90, 101, 111, 122, 132, 143, 154, 164, 175, 186, 196, 207, 218, 228, 239, 250, 261, 272],
    &#x27;29&#x27;: [13, 22, 32, 42, 52, 62, 73, 83, 94, 105, 116, 127, 138, 149, 160, 171, 182, 193, 204, 215, 226, 238, 249, 260, 271, 282, 294],
    &#x27;30&#x27;: [13, 23, 33, 43, 54, 65, 76, 87, 98, 109, 120, 131, 143, 154, 166, 177, 189, 200, 212, 223, 235, 247, 258, 270, 282, 293, 305, 317]
  };

  /**
   * An object used to flag environments/features.
   *
   * @static
   * @memberOf Benchmark
   * @type Object
   */
  var support = {};

  (function() {

    /**
     * Detect Adobe AIR.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.air = isClassOf(window.runtime, &#x27;ScriptBridgingProxyObject&#x27;);

    /**
     * Detect if &#x60;arguments&#x60; objects have the correct internal [[Class]] value.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.argumentsClass = isClassOf(arguments, &#x27;Arguments&#x27;);

    /**
     * Detect if in a browser environment.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.browser = doc &amp;&amp; isHostType(window, &#x27;navigator&#x27;);

    /**
     * Detect if strings support accessing characters by index.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.charByIndex =
      // IE 8 supports indexes on string literals but not string objects
      (&#x27;x&#x27;[0] + Object(&#x27;x&#x27;)[0]) == &#x27;xx&#x27;;

    /**
     * Detect if strings have indexes as own properties.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.charByOwnIndex =
      // Narwhal, Rhino, RingoJS, IE 8, and Opera &lt; 10.52 support indexes on
      // strings but don&#x27;t detect them as own properties
      support.charByIndex &amp;&amp; hasKey(&#x27;x&#x27;, &#x27;0&#x27;);

    /**
     * Detect if Java is enabled/exposed.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.java = isClassOf(window.java, &#x27;JavaPackage&#x27;);

    /**
     * Detect if the Timers API exists.
     *
     * @memberOf Benchmark.support
     * @type Boolean
     */
    support.timeout = isHostType(window, &#x27;setTimeout&#x27;) &amp;&amp; isHostType(window, &#x27;clearTimeout&#x27;);

    /**
     * Detect if functions support decompilation.
     *
     * @name decompilation
     * @memberOf Benchmark.support
     * @type Boolean
     */
    try {
      // Safari 2.x removes commas in object literals
      // from Function#toString results
      // http://webk.it/11609
      // Firefox 3.6 and Opera 9.25 strip grouping
      // parentheses from Function#toString results
      // http://bugzil.la/559438
      support.decompilation = Function(
        &#x27;return (&#x27; + (function(x) { return { &#x27;x&#x27;: &#x27;&#x27; + (1 + x) + &#x27;&#x27;, &#x27;y&#x27;: 0 }; }) + &#x27;)&#x27;
      )()(0).x === &#x27;1&#x27;;
    } catch(e) {
      support.decompilation = false;
    }

    /**
     * Detect ES5+ property descriptor API.
     *
     * @name descriptors
     * @memberOf Benchmark.support
     * @type Boolean
     */
    try {
      var o = {};
      support.descriptors = (setDescriptor(o, o, o), &#x27;value&#x27; in getDescriptor(o, o));
    } catch(e) {
      support.descriptors = false;
    }

    /**
     * Detect ES5+ Object.getOwnPropertyNames().
     *
     * @name getAllKeys
     * @memberOf Benchmark.support
     * @type Boolean
     */
    try {
      support.getAllKeys = /\bvalueOf\b/.test(getAllKeys(Object.prototype));
    } catch(e) {
      support.getAllKeys = false;
    }
  }());

  /**
   * Timer object used by &#x60;clock()&#x60; and &#x60;Deferred#resolve&#x60;.
   *
   * @private
   * @type Object
   */
  var timer = {

   /**
    * The timer namespace object or constructor.
    *
    * @private
    * @memberOf timer
    * @type Function|Object
    */
    &#x27;ns&#x27;: Date,

   /**
    * Starts the deferred timer.
    *
    * @private
    * @memberOf timer
    * @param {Object} deferred The deferred instance.
    */
    &#x27;start&#x27;: null, // lazy defined in &#x60;clock()&#x60;

   /**
    * Stops the deferred timer.
    *
    * @private
    * @memberOf timer
    * @param {Object} deferred The deferred instance.
    */
    &#x27;stop&#x27;: null // lazy defined in &#x60;clock()&#x60;
  };

  /** Shortcut for inverse results */
  var noArgumentsClass = !support.argumentsClass,
      noCharByIndex = !support.charByIndex,
      noCharByOwnIndex = !support.charByOwnIndex;

  /** Math shortcuts */
  var abs   = Math.abs,
      floor = Math.floor,
      max   = Math.max,
      min   = Math.min,
      pow   = Math.pow,
      sqrt  = Math.sqrt;

  /*--------------------------------------------------------------------------*/

  /**
   * The Benchmark constructor.
   *
   * @constructor
   * @param {String} name A name to identify the benchmark.
   * @param {Function|String} fn The test to benchmark.
   * @param {Object} [options={}] Options object.
   * @example
   *
   * // basic usage (the &#x60;new&#x60; operator is optional)
   * var bench = new Benchmark(fn);
   *
   * // or using a name first
   * var bench = new Benchmark(&#x27;foo&#x27;, fn);
   *
   * // or with options
   * var bench = new Benchmark(&#x27;foo&#x27;, fn, {
   *
   *   // displayed by Benchmark#toString if &#x60;name&#x60; is not available
   *   &#x27;id&#x27;: &#x27;xyz&#x27;,
   *
   *   // called when the benchmark starts running
   *   &#x27;onStart&#x27;: onStart,
   *
   *   // called after each run cycle
   *   &#x27;onCycle&#x27;: onCycle,
   *
   *   // called when aborted
   *   &#x27;onAbort&#x27;: onAbort,
   *
   *   // called when a test errors
   *   &#x27;onError&#x27;: onError,
   *
   *   // called when reset
   *   &#x27;onReset&#x27;: onReset,
   *
   *   // called when the benchmark completes running
   *   &#x27;onComplete&#x27;: onComplete,
   *
   *   // compiled/called before the test loop
   *   &#x27;setup&#x27;: setup,
   *
   *   // compiled/called after the test loop
   *   &#x27;teardown&#x27;: teardown
   * });
   *
   * // or name and options
   * var bench = new Benchmark(&#x27;foo&#x27;, {
   *
   *   // a flag to indicate the benchmark is deferred
   *   &#x27;defer&#x27;: true,
   *
   *   // benchmark test function
   *   &#x27;fn&#x27;: function(deferred) {
   *     // call resolve() when the deferred test is finished
   *     deferred.resolve();
   *   }
   * });
   *
   * // or options only
   * var bench = new Benchmark({
   *
   *   // benchmark name
   *   &#x27;name&#x27;: &#x27;foo&#x27;,
   *
   *   // benchmark test as a string
   *   &#x27;fn&#x27;: &#x27;[1,2,3,4].sort()&#x27;
   * });
   *
   * // a test&#x27;s &#x60;this&#x60; binding is set to the benchmark instance
   * var bench = new Benchmark(&#x27;foo&#x27;, function() {
   *   &#x27;My name is &#x27;.concat(this.name); // My name is foo
   * });
   */
  function Benchmark(name, fn, options) {
    var me = this;

    // allow instance creation without the &#x60;new&#x60; operator
    if (me == null || me.constructor != Benchmark) {
      return new Benchmark(name, fn, options);
    }
    // juggle arguments
    if (isClassOf(name, &#x27;Object&#x27;)) {
      // 1 argument (options)
      options = name;
    }
    else if (isClassOf(name, &#x27;Function&#x27;)) {
      // 2 arguments (fn, options)
      options = fn;
      fn = name;
    }
    else if (isClassOf(fn, &#x27;Object&#x27;)) {
      // 2 arguments (name, options)
      options = fn;
      fn = null;
      me.name = name;
    }
    else {
      // 3 arguments (name, fn [, options])
      me.name = name;
    }
    setOptions(me, options);
    me.id || (me.id = ++counter);
    me.fn == null &amp;&amp; (me.fn = fn);
    me.stats = deepClone(me.stats);
    me.times = deepClone(me.times);
  }

  /**
   * The Deferred constructor.
   *
   * @constructor
   * @memberOf Benchmark
   * @param {Object} clone The cloned benchmark instance.
   */
  function Deferred(clone) {
    var me = this;
    if (me == null || me.constructor != Deferred) {
      return new Deferred(clone);
    }
    me.benchmark = clone;
    clock(me);
  }

  /**
   * The Event constructor.
   *
   * @constructor
   * @memberOf Benchmark
   * @param {String|Object} type The event type.
   */
  function Event(type) {
    var me = this;
    return (me == null || me.constructor != Event)
      ? new Event(type)
      : (type instanceof Event)
          ? type
          : extend(me, { &#x27;timeStamp&#x27;: +new Date }, typeof type == &#x27;string&#x27; ? { &#x27;type&#x27;: type } : type);
  }

  /**
   * The Suite constructor.
   *
   * @constructor
   * @memberOf Benchmark
   * @param {String} name A name to identify the suite.
   * @param {Object} [options={}] Options object.
   * @example
   *
   * // basic usage (the &#x60;new&#x60; operator is optional)
   * var suite = new Benchmark.Suite;
   *
   * // or using a name first
   * var suite = new Benchmark.Suite(&#x27;foo&#x27;);
   *
   * // or with options
   * var suite = new Benchmark.Suite(&#x27;foo&#x27;, {
   *
   *   // called when the suite starts running
   *   &#x27;onStart&#x27;: onStart,
   *
   *   // called between running benchmarks
   *   &#x27;onCycle&#x27;: onCycle,
   *
   *   // called when aborted
   *   &#x27;onAbort&#x27;: onAbort,
   *
   *   // called when a test errors
   *   &#x27;onError&#x27;: onError,
   *
   *   // called when reset
   *   &#x27;onReset&#x27;: onReset,
   *
   *   // called when the suite completes running
   *   &#x27;onComplete&#x27;: onComplete
   * });
   */
  function Suite(name, options) {
    var me = this;

    // allow instance creation without the &#x60;new&#x60; operator
    if (me == null || me.constructor != Suite) {
      return new Suite(name, options);
    }
    // juggle arguments
    if (isClassOf(name, &#x27;Object&#x27;)) {
      // 1 argument (options)
      options = name;
    } else {
      // 2 arguments (name [, options])
      me.name = name;
    }
    setOptions(me, options);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Note: Some array methods have been implemented in plain JavaScript to avoid
   * bugs in IE, Opera, Rhino, and Mobile Safari.
   *
   * IE compatibility mode and IE &lt; 9 have buggy Array &#x60;shift()&#x60; and &#x60;splice()&#x60;
   * functions that fail to remove the last element, &#x60;object[0]&#x60;, of
   * array-like-objects even though the &#x60;length&#x60; property is set to &#x60;0&#x60;.
   * The &#x60;shift()&#x60; method is buggy in IE 8 compatibility mode, while &#x60;splice()&#x60;
   * is buggy regardless of mode in IE &lt; 9 and buggy in compatibility mode in IE 9.
   *
   * In Opera &lt; 9.50 and some older/beta Mobile Safari versions using &#x60;unshift()&#x60;
   * generically to augment the &#x60;arguments&#x60; object will pave the value at index 0
   * without incrimenting the other values&#x27;s indexes.
   * https://github.com/documentcloud/underscore/issues/9
   *
   * Rhino and environments it powers, like Narwhal and RingoJS, may have
   * buggy Array &#x60;concat()&#x60;, &#x60;reverse()&#x60;, &#x60;shift()&#x60;, &#x60;slice()&#x60;, &#x60;splice()&#x60; and
   * &#x60;unshift()&#x60; functions that make sparse arrays non-sparse by assigning the
   * undefined indexes a value of undefined.
   * https://github.com/mozilla/rhino/commit/702abfed3f8ca043b2636efd31c14ba7552603dd
   */

  /**
   * Creates an array containing the elements of the host array followed by the
   * elements of each argument in order.
   *
   * @memberOf Benchmark.Suite
   * @returns {Array} The new array.
   */
  function concat() {
    var value,
        j = -1,
        length = arguments.length,
        result = slice.call(this),
        index = result.length;

    while (++j &lt; length) {
      value = arguments[j];
      if (isClassOf(value, &#x27;Array&#x27;)) {
        for (var k = 0, l = value.length; k &lt; l; k++, index++) {
          if (k in value) {
            result[index] = value[k];
          }
        }
      } else {
        result[index++] = value;
      }
    }
    return result;
  }

  /**
   * Utility function used by &#x60;shift()&#x60;, &#x60;splice()&#x60;, and &#x60;unshift()&#x60;.
   *
   * @private
   * @param {Number} start The index to start inserting elements.
   * @param {Number} deleteCount The number of elements to delete from the insert point.
   * @param {Array} elements The elements to insert.
   * @returns {Array} An array of deleted elements.
   */
  function insert(start, deleteCount, elements) {
    // &#x60;result&#x60; should have its length set to the &#x60;deleteCount&#x60;
    // see https://bugs.ecmascript.org/show_bug.cgi?id=332
    var deleteEnd = start + deleteCount,
        elementCount = elements ? elements.length : 0,
        index = start - 1,
        length = start + elementCount,
        object = this,
        result = Array(deleteCount),
        tail = slice.call(object, deleteEnd);

    // delete elements from the array
    while (++index &lt; deleteEnd) {
      if (index in object) {
        result[index - start] = object[index];
        delete object[index];
      }
    }
    // insert elements
    index = start - 1;
    while (++index &lt; length) {
      object[index] = elements[index - start];
    }
    // append tail elements
    start = index--;
    length = max(0, (object.length &gt;&gt;&gt; 0) - deleteCount + elementCount);
    while (++index &lt; length) {
      if ((index - start) in tail) {
        object[index] = tail[index - start];
      } else {
        delete object[index];
      }
    }
    // delete excess elements
    deleteCount = deleteCount &gt; elementCount ? deleteCount - elementCount : 0;
    while (deleteCount--) {
      delete object[length + deleteCount];
    }
    object.length = length;
    return result;
  }

  /**
   * Rearrange the host array&#x27;s elements in reverse order.
   *
   * @memberOf Benchmark.Suite
   * @returns {Array} The reversed array.
   */
  function reverse() {
    var upperIndex,
        value,
        index = -1,
        object = Object(this),
        length = object.length &gt;&gt;&gt; 0,
        middle = floor(length / 2);

    if (length &gt; 1) {
      while (++index &lt; middle) {
        upperIndex = length - index - 1;
        value = upperIndex in object ? object[upperIndex] : uid;
        if (index in object) {
          object[upperIndex] = object[index];
        } else {
          delete object[upperIndex];
        }
        if (value != uid) {
          object[index] = value;
        } else {
          delete object[index];
        }
      }
    }
    return object;
  }

  /**
   * Removes the first element of the host array and returns it.
   *
   * @memberOf Benchmark.Suite
   * @returns {Mixed} The first element of the array.
   */
  function shift() {
    return insert.call(this, 0, 1)[0];
  }

  /**
   * Creates an array of the host array&#x27;s elements from the start index up to,
   * but not including, the end index.
   *
   * @memberOf Benchmark.Suite
   * @param {Number} start The starting index.
   * @param {Number} end The end index.
   * @returns {Array} The new array.
   */
  function slice(start, end) {
    var index = -1,
        object = Object(this),
        length = object.length &gt;&gt;&gt; 0,
        result = [];

    start = toInteger(start);
    start = start &lt; 0 ? max(length + start, 0) : min(start, length);
    start--;
    end = end == null ? length : toInteger(end);
    end = end &lt; 0 ? max(length + end, 0) : min(end, length);

    while ((++index, ++start) &lt; end) {
      if (start in object) {
        result[index] = object[start];
      }
    }
    return result;
  }

  /**
   * Allows removing a range of elements and/or inserting elements into the
   * host array.
   *
   * @memberOf Benchmark.Suite
   * @param {Number} start The start index.
   * @param {Number} deleteCount The number of elements to delete.
   * @param {Mixed} [val1, val2, ...] values to insert at the &#x60;start&#x60; index.
   * @returns {Array} An array of removed elements.
   */
  function splice(start, deleteCount) {
    var object = Object(this),
        length = object.length &gt;&gt;&gt; 0;

    start = toInteger(start);
    start = start &lt; 0 ? max(length + start, 0) : min(start, length);
    deleteCount = min(max(toInteger(deleteCount), 0), length - start);
    return insert.call(object, start, deleteCount, slice.call(arguments, 2));
  }

  /**
   * Converts the specified &#x60;value&#x60; to an integer.
   *
   * @private
   * @param {Mixed} value The value to convert.
   * @returns {Number} The resulting integer.
   */
  function toInteger(value) {
    value = +value;
    return value === 0 || !isFinite(value) ? value || 0 : value - (value % 1);
  }

  /**
   * Appends arguments to the host array.
   *
   * @memberOf Benchmark.Suite
   * @returns {Number} The new length.
   */
  function unshift() {
    var object = Object(this);
    insert.call(object, 0, 0, arguments);
    return object.length;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * A generic &#x60;Function#bind&#x60; like method.
   *
   * @private
   * @param {Function} fn The function to be bound to &#x60;thisArg&#x60;.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the given function.
   * @returns {Function} The bound function.
   */
  function bind(fn, thisArg) {
    return function() { fn.apply(thisArg, arguments); };
  }

  /**
   * Creates a function from the given arguments string and body.
   *
   * @private
   * @param {String} args The comma separated function arguments.
   * @param {String} body The function body.
   * @returns {Function} The new function.
   */
  function createFunction() {
    // lazy define
    createFunction = function(args, body) {
      var result,
          anchor = freeDefine ? define.amd : Benchmark,
          prop = uid + &#x27;createFunction&#x27;;

      runScript((freeDefine ? &#x27;define.amd.&#x27; : &#x27;Benchmark.&#x27;) + prop + &#x27;=function(&#x27; + args + &#x27;){&#x27; + body + &#x27;}&#x27;);
      result = anchor[prop];
      delete anchor[prop];
      return result;
    };
    // fix JaegerMonkey bug
    // http://bugzil.la/639720
    createFunction = support.browser &amp;&amp; (createFunction(&#x27;&#x27;, &#x27;return&quot;&#x27; + uid + &#x27;&quot;&#x27;) || noop)() == uid ? createFunction : Function;
    return createFunction.apply(null, arguments);
  }

  /**
   * Delay the execution of a function based on the benchmark&#x27;s &#x60;delay&#x60; property.
   *
   * @private
   * @param {Object} bench The benchmark instance.
   * @param {Object} fn The function to execute.
   */
  function delay(bench, fn) {
    bench._timerId = setTimeout(fn, bench.delay * 1e3);
  }

  /**
   * Destroys the given element.
   *
   * @private
   * @param {Element} element The element to destroy.
   */
  function destroyElement(element) {
    trash.appendChild(element);
    trash.innerHTML = &#x27;&#x27;;
  }

  /**
   * Iterates over an object&#x27;s properties, executing the &#x60;callback&#x60; for each.
   * Callbacks may terminate the loop by explicitly returning &#x60;false&#x60;.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   * @param {Object} options The options object.
   * @returns {Object} Returns the object iterated over.
   */
  function forProps() {
    var forShadowed,
        skipSeen,
        forArgs = true,
        shadowed = [&#x27;constructor&#x27;, &#x27;hasOwnProperty&#x27;, &#x27;isPrototypeOf&#x27;, &#x27;propertyIsEnumerable&#x27;, &#x27;toLocaleString&#x27;, &#x27;toString&#x27;, &#x27;valueOf&#x27;];

    (function(enumFlag, key) {
      // must use a non-native constructor to catch the Safari 2 issue
      function Klass() { this.valueOf = 0; };
      Klass.prototype.valueOf = 0;
      // check various for-in bugs
      for (key in new Klass) {
        enumFlag += key == &#x27;valueOf&#x27; ? 1 : 0;
      }
      // check if &#x60;arguments&#x60; objects have non-enumerable indexes
      for (key in arguments) {
        key == &#x27;0&#x27; &amp;&amp; (forArgs = false);
      }
      // Safari 2 iterates over shadowed properties twice
      // http://replay.waybackmachine.org/20090428222941/http://tobielangel.com/2007/1/29/for-in-loop-broken-in-safari/
      skipSeen = enumFlag == 2;
      // IE &lt; 9 incorrectly makes an object&#x27;s properties non-enumerable if they have
      // the same name as other non-enumerable properties in its prototype chain.
      forShadowed = !enumFlag;
    }(0));

    // lazy define
    forProps = function(object, callback, options) {
      options || (options = {});

      var result = object;
      object = Object(object);

      var ctor,
          key,
          keys,
          skipCtor,
          done = !result,
          which = options.which,
          allFlag = which == &#x27;all&#x27;,
          index = -1,
          iteratee = object,
          length = object.length,
          ownFlag = allFlag || which == &#x27;own&#x27;,
          seen = {},
          skipProto = isClassOf(object, &#x27;Function&#x27;),
          thisArg = options.bind;

      if (thisArg !== undefined) {
        callback = bind(callback, thisArg);
      }
      // iterate all properties
      if (allFlag &amp;&amp; support.getAllKeys) {
        for (index = 0, keys = getAllKeys(object), length = keys.length; index &lt; length; index++) {
          key = keys[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
      }
      // else iterate only enumerable properties
      else {
        for (key in object) {
          // Firefox &lt; 3.6, Opera &gt; 9.50 - Opera &lt; 11.60, and Safari &lt; 5.1
          // (if the prototype or a property on the prototype has been set)
          // incorrectly set a function&#x27;s &#x60;prototype&#x60; property [[Enumerable]] value
          // to &#x60;true&#x60;. Because of this we standardize on skipping the &#x60;prototype&#x60;
          // property of functions regardless of their [[Enumerable]] value.
          if ((done =
              !(skipProto &amp;&amp; key == &#x27;prototype&#x27;) &amp;&amp;
              !(skipSeen &amp;&amp; (hasKey(seen, key) || !(seen[key] = true))) &amp;&amp;
              (!ownFlag || ownFlag &amp;&amp; hasKey(object, key)) &amp;&amp;
              callback(object[key], key, object) === false)) {
            break;
          }
        }
        // in IE &lt; 9 strings don&#x27;t support accessing characters by index
        if (!done &amp;&amp; (forArgs &amp;&amp; isArguments(object) ||
            ((noCharByIndex || noCharByOwnIndex) &amp;&amp; isClassOf(object, &#x27;String&#x27;) &amp;&amp;
              (iteratee = noCharByIndex ? object.split(&#x27;&#x27;) : object)))) {
          while (++index &lt; length) {
            if ((done =
                callback(iteratee[index], String(index), object) === false)) {
              break;
            }
          }
        }
        if (!done &amp;&amp; forShadowed) {
          // Because IE &lt; 9 can&#x27;t set the &#x60;[[Enumerable]]&#x60; attribute of an existing
          // property and the &#x60;constructor&#x60; property of a prototype defaults to
          // non-enumerable, we manually skip the &#x60;constructor&#x60; property when we
          // think we are iterating over a &#x60;prototype&#x60; object.
          ctor = object.constructor;
          skipCtor = ctor &amp;&amp; ctor.prototype &amp;&amp; ctor.prototype.constructor === ctor;
          for (index = 0; index &lt; 7; index++) {
            key = shadowed[index];
            if (!(skipCtor &amp;&amp; key == &#x27;constructor&#x27;) &amp;&amp;
                hasKey(object, key) &amp;&amp;
                callback(object[key], key, object) === false) {
              break;
            }
          }
        }
      }
      return result;
    };
    return forProps.apply(null, arguments);
  }

  /**
   * Gets the name of the first argument from a function&#x27;s source.
   *
   * @private
   * @param {Function} fn The function.
   * @returns {String} The argument name.
   */
  function getFirstArgument(fn) {
    return (!hasKey(fn, &#x27;toString&#x27;) &amp;&amp;
      (/^[\s(]*function[^(]*\(([^\s,)]+)/.exec(fn) || 0)[1]) || &#x27;&#x27;;
  }

  /**
   * Computes the arithmetic mean of a sample.
   *
   * @private
   * @param {Array} sample The sample.
   * @returns {Number} The mean.
   */
  function getMean(sample) {
    return reduce(sample, function(sum, x) {
      return sum + x;
    }) / sample.length || 0;
  }

  /**
   * Gets the source code of a function.
   *
   * @private
   * @param {Function} fn The function.
   * @param {String} altSource A string used when a function&#x27;s source code is unretrievable.
   * @returns {String} The function&#x27;s source code.
   */
  function getSource(fn, altSource) {
    var result = altSource;
    if (isStringable(fn)) {
      result = String(fn);
    } else if (support.decompilation) {
      // escape the &#x60;{&#x60; for Firefox 1
      result = (/^[^{]+\{([\s\S]*)}\s*$/.exec(fn) || 0)[1];
    }
    return (result || &#x27;&#x27;).replace(/^\s+|\s+$/g, &#x27;&#x27;);
  }

  /**
   * Checks if a value is an &#x60;arguments&#x60; object.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns &#x60;true&#x60; if the value is an &#x60;arguments&#x60; object, else &#x60;false&#x60;.
   */
  function isArguments() {
    // lazy define
    isArguments = function(value) {
      return toString.call(value) == &#x27;[object Arguments]&#x27;;
    };
    if (noArgumentsClass) {
      isArguments = function(value) {
        return hasKey(value, &#x27;callee&#x27;) &amp;&amp;
          !(propertyIsEnumerable &amp;&amp; propertyIsEnumerable.call(value, &#x27;callee&#x27;));
      };
    }
    return isArguments(arguments[0]);
  }

  /**
   * Checks if an object is of the specified class.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @param {String} name The name of the class.
   * @returns {Boolean} Returns &#x60;true&#x60; if the value is of the specified class, else &#x60;false&#x60;.
   */
  function isClassOf(value, name) {
    return value != null &amp;&amp; toString.call(value) == &#x27;[object &#x27; + name + &#x27;]&#x27;;
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of object, function, or unknown.
   *
   * @private
   * @param {Mixed} object The owner of the property.
   * @param {String} property The property to check.
   * @returns {Boolean} Returns &#x60;true&#x60; if the property value is a non-primitive, else &#x60;false&#x60;.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : &#x27;number&#x27;;
    return !/^(?:boolean|number|string|undefined)$/.test(type) &amp;&amp;
      (type == &#x27;object&#x27; ? !!object[property] : true);
  }

  /**
   * Checks if the specified &#x60;value&#x60; is an object created by the &#x60;Object&#x60;
   * constructor assuming objects created by the &#x60;Object&#x60; constructor have no
   * inherited enumerable properties and assuming there are no &#x60;Object.prototype&#x60;
   * extensions.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns &#x60;true&#x60; if &#x60;value&#x60; is an object, else &#x60;false&#x60;.
   */
  function isObject(value) {
    var ctor,
        result = !!value &amp;&amp; toString.call(value) == &#x27;[object Object]&#x27;;

    if (result &amp;&amp; noArgumentsClass) {
      // avoid false positives for &#x60;arguments&#x60; objects in IE &lt; 9
      result = !isArguments(value);
    }
    if (result) {
      // IE &lt; 9 presents nodes like &#x60;Object&#x60; objects:
      // IE &lt; 8 are missing the node&#x27;s constructor property
      // IE 8 node constructors are typeof &quot;object&quot;
      ctor = value.constructor;
      // check if the constructor is &#x60;Object&#x60; as &#x60;Object instanceof Object&#x60; is &#x60;true&#x60;
      if ((result = isClassOf(ctor, &#x27;Function&#x27;) &amp;&amp; ctor instanceof ctor)) {
        // An object&#x27;s own properties are iterated before inherited properties.
        // If the last iterated key belongs to an object&#x27;s own property then
        // there are no inherited enumerable properties.
        forProps(value, function(subValue, subKey) { result = subKey; });
        result = result === true || hasKey(value, result);
      }
    }
    return result;
  }

  /**
   * Checks if a value can be safely coerced to a string.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns &#x60;true&#x60; if the value can be coerced, else &#x60;false&#x60;.
   */
  function isStringable(value) {
    return hasKey(value, &#x27;toString&#x27;) || isClassOf(value, &#x27;String&#x27;);
  }

  /**
   * Wraps a function and passes &#x60;this&#x60; to the original function as the
   * first argument.
   *
   * @private
   * @param {Function} fn The function to be wrapped.
   * @returns {Function} The new function.
   */
  function methodize(fn) {
    return function() {
      var args = [this];
      args.push.apply(args, arguments);
      return fn.apply(null, args);
    };
  }

  /**
   * A no-operation function.
   *
   * @private
   */
  function noop() {
    // no operation performed
  }

  /**
   * A wrapper around require() to suppress &#x60;module missing&#x60; errors.
   *
   * @private
   * @param {String} id The module id.
   * @returns {Mixed} The exported module or &#x60;null&#x60;.
   */
  function req(id) {
    try {
      var result = freeExports &amp;&amp; freeRequire(id);
    } catch(e) { }
    return result || null;
  }

  /**
   * Runs a snippet of JavaScript via script injection.
   *
   * @private
   * @param {String} code The code to run.
   */
  function runScript(code) {
    var anchor = freeDefine ? define.amd : Benchmark,
        script = doc.createElement(&#x27;script&#x27;),
        sibling = doc.getElementsByTagName(&#x27;script&#x27;)[0],
        parent = sibling.parentNode,
        prop = uid + &#x27;runScript&#x27;,
        prefix = &#x27;(&#x27; + (freeDefine ? &#x27;define.amd.&#x27; : &#x27;Benchmark.&#x27;) + prop + &#x27;||function(){})();&#x27;;

    // Firefox 2.0.0.2 cannot use script injection as intended because it executes
    // asynchronously, but that&#x27;s OK because script injection is only used to avoid
    // the previously commented JaegerMonkey bug.
    try {
      // remove the inserted script *before* running the code to avoid differences
      // in the expected script element count/order of the document.
      script.appendChild(doc.createTextNode(prefix + code));
      anchor[prop] = function() { destroyElement(script); };
    } catch(e) {
      parent = parent.cloneNode(false);
      sibling = null;
      script.text = code;
    }
    parent.insertBefore(script, sibling);
    delete anchor[prop];
  }

  /**
   * A helper function for setting options/event handlers.
   *
   * @private
   * @param {Object} bench The benchmark instance.
   * @param {Object} [options={}] Options object.
   */
  function setOptions(bench, options) {
    options = extend({}, bench.constructor.options, options);
    bench.options = forOwn(options, function(value, key) {
      if (value != null) {
        // add event listeners
        if (/^on[A-Z]/.test(key)) {
          forEach(key.split(&#x27; &#x27;), function(key) {
            bench.on(key.slice(2).toLowerCase(), value);
          });
        } else if (!hasKey(bench, key)) {
          bench[key] = deepClone(value);
        }
      }
    });
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Handles cycling/completing the deferred benchmark.
   *
   * @memberOf Benchmark.Deferred
   */
  function resolve() {
    var me = this,
        clone = me.benchmark,
        bench = clone._original;

    if (bench.aborted) {
      // cycle() -&gt; clone cycle/complete event -&gt; compute()&#x27;s invoked bench.run() cycle/complete
      me.teardown();
      clone.running = false;
      cycle(me);
    }
    else if (++me.cycles &lt; clone.count) {
      // continue the test loop
      if (support.timeout) {
        // use setTimeout to avoid a call stack overflow if called recursively
        setTimeout(function() { clone.compiled.call(me, timer); }, 0);
      } else {
        clone.compiled.call(me, timer);
      }
    }
    else {
      timer.stop(me);
      me.teardown();
      delay(clone, function() { cycle(me); });
    }
  }

  /*--------------------------------------------------------------------------*/

  /**
   * A deep clone utility.
   *
   * @static
   * @memberOf Benchmark
   * @param {Mixed} value The value to clone.
   * @returns {Mixed} The cloned value.
   */
  function deepClone(value) {
    var accessor,
        circular,
        clone,
        ctor,
        descriptor,
        extensible,
        key,
        length,
        markerKey,
        parent,
        result,
        source,
        subIndex,
        data = { &#x27;value&#x27;: value },
        index = 0,
        marked = [],
        queue = { &#x27;length&#x27;: 0 },
        unmarked = [];

    /**
     * An easily detectable decorator for cloned values.
     */
    function Marker(object) {
      this.raw = object;
    }

    /**
     * The callback used by &#x60;forProps()&#x60;.
     */
    function forPropsCallback(subValue, subKey) {
      // exit early to avoid cloning the marker
      if (subValue &amp;&amp; subValue.constructor == Marker) {
        return;
      }
      // add objects to the queue
      if (subValue === Object(subValue)) {
        queue[queue.length++] = { &#x27;key&#x27;: subKey, &#x27;parent&#x27;: clone, &#x27;source&#x27;: value };
      }
      // assign non-objects
      else {
        try {
          // will throw an error in strict mode if the property is read-only
          clone[subKey] = subValue;
        } catch(e) { }
      }
    }

    /**
     * Gets an available marker key for the given object.
     */
    function getMarkerKey(object) {
      // avoid collisions with existing keys
      var result = uid;
      while (object[result] &amp;&amp; object[result].constructor != Marker) {
        result += 1;
      }
      return result;
    }

    do {
      key = data.key;
      parent = data.parent;
      source = data.source;
      clone = value = source ? source[key] : data.value;
      accessor = circular = descriptor = false;

      // create a basic clone to filter out functions, DOM elements, and
      // other non &#x60;Object&#x60; objects
      if (value === Object(value)) {
        // use custom deep clone function if available
        if (isClassOf(value.deepClone, &#x27;Function&#x27;)) {
          clone = value.deepClone();
        } else {
          ctor = value.constructor;
          switch (toString.call(value)) {
            case &#x27;[object Array]&#x27;:
              clone = new ctor(value.length);
              break;

            case &#x27;[object Boolean]&#x27;:
              clone = new ctor(value == true);
              break;

            case &#x27;[object Date]&#x27;:
              clone = new ctor(+value);
              break;

            case &#x27;[object Object]&#x27;:
              isObject(value) &amp;&amp; (clone = new ctor);
              break;

            case &#x27;[object Number]&#x27;:
            case &#x27;[object String]&#x27;:
              clone = new ctor(value);
              break;

            case &#x27;[object RegExp]&#x27;:
              clone = ctor(value.source,
                (value.global     ? &#x27;g&#x27; : &#x27;&#x27;) +
                (value.ignoreCase ? &#x27;i&#x27; : &#x27;&#x27;) +
                (value.multiline  ? &#x27;m&#x27; : &#x27;&#x27;));
          }
        }
        // continue clone if &#x60;value&#x60; doesn&#x27;t have an accessor descriptor
        // http://es5.github.com/#x8.10.1
        if (clone &amp;&amp; clone != value &amp;&amp;
            !(descriptor = source &amp;&amp; support.descriptors &amp;&amp; getDescriptor(source, key),
              accessor = descriptor &amp;&amp; (descriptor.get || descriptor.set))) {
          // use an existing clone (circular reference)
          if ((extensible = isExtensible(value))) {
            markerKey = getMarkerKey(value);
            if (value[markerKey]) {
              circular = clone = value[markerKey].raw;
            }
          } else {
            // for frozen/sealed objects
            for (subIndex = 0, length = unmarked.length; subIndex &lt; length; subIndex++) {
              data = unmarked[subIndex];
              if (data.object === value) {
                circular = clone = data.clone;
                break;
              }
            }
          }
          if (!circular) {
            // mark object to allow quickly detecting circular references and tie it to its clone
            if (extensible) {
              value[markerKey] = new Marker(clone);
              marked.push({ &#x27;key&#x27;: markerKey, &#x27;object&#x27;: value });
            } else {
              // for frozen/sealed objects
              unmarked.push({ &#x27;clone&#x27;: clone, &#x27;object&#x27;: value });
            }
            // iterate over object properties
            forProps(value, forPropsCallback, { &#x27;which&#x27;: &#x27;all&#x27; });
          }
        }
      }
      if (parent) {
        // for custom property descriptors
        if (accessor || (descriptor &amp;&amp; !(descriptor.configurable &amp;&amp; descriptor.enumerable &amp;&amp; descriptor.writable))) {
          if (&#x27;value&#x27; in descriptor) {
            descriptor.value = clone;
          }
          setDescriptor(parent, key, descriptor);
        }
        // for default property descriptors
        else {
          parent[key] = clone;
        }
      } else {
        result = clone;
      }
    } while ((data = queue[index++]));

    // remove markers
    for (index = 0, length = marked.length; index &lt; length; index++) {
      data = marked[index];
      delete data.object[data.key];
    }
    return result;
  }

  /**
   * An iteration utility for arrays and objects.
   * Callbacks may terminate the loop by explicitly returning &#x60;false&#x60;.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the callback.
   * @returns {Array|Object} Returns the object iterated over.
   */
  function each(object, callback, thisArg) {
    var result = object;
    object = Object(object);

    var fn = callback,
        index = -1,
        length = object.length,
        isSnapshot = !!(object.snapshotItem &amp;&amp; (length = object.snapshotLength)),
        isSplittable = (noCharByIndex || noCharByOwnIndex) &amp;&amp; isClassOf(object, &#x27;String&#x27;),
        isConvertable = isSnapshot || isSplittable || &#x27;item&#x27; in object,
        origObject = object;

    // in Opera &lt; 10.5 &#x60;hasKey(object, &#x27;length&#x27;)&#x60; returns &#x60;false&#x60; for NodeLists
    if (length === length &gt;&gt;&gt; 0) {
      if (isConvertable) {
        // the third argument of the callback is the original non-array object
        callback = function(value, index) {
          return fn.call(this, value, index, origObject);
        };
        // in IE &lt; 9 strings don&#x27;t support accessing characters by index
        if (isSplittable) {
          object = object.split(&#x27;&#x27;);
        } else {
          object = [];
          while (++index &lt; length) {
            // in Safari 2 &#x60;index in object&#x60; is always &#x60;false&#x60; for NodeLists
            object[index] = isSnapshot ? result.snapshotItem(index) : result[index];
          }
        }
      }
      forEach(object, callback, thisArg);
    } else {
      forOwn(object, callback, thisArg);
    }
    return result;
  }

  /**
   * Copies enumerable properties from the source(s) object to the destination object.
   *
   * @static
   * @memberOf Benchmark
   * @param {Object} destination The destination object.
   * @param {Object} [source={}] The source object.
   * @returns {Object} The destination object.
   */
  function extend(destination, source) {
    // Chrome &lt; 14 incorrectly sets &#x60;destination&#x60; to &#x60;undefined&#x60; when we &#x60;delete arguments[0]&#x60;
    // http://code.google.com/p/v8/issues/detail?id=839
    var result = destination;
    delete arguments[0];

    forEach(arguments, function(source) {
      forProps(source, function(value, key) {
        result[key] = value;
      });
    });
    return result;
  }

  /**
   * A generic &#x60;Array#filter&#x60; like method.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {Function|String} callback The function/alias called per iteration.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the callback.
   * @returns {Array} A new array of values that passed callback filter.
   * @example
   *
   * // get odd numbers
   * Benchmark.filter([1, 2, 3, 4, 5], function(n) {
   *   return n % 2;
   * }); // -&gt; [1, 3, 5];
   *
   * // get fastest benchmarks
   * Benchmark.filter(benches, &#x27;fastest&#x27;);
   *
   * // get slowest benchmarks
   * Benchmark.filter(benches, &#x27;slowest&#x27;);
   *
   * // get benchmarks that completed without erroring
   * Benchmark.filter(benches, &#x27;successful&#x27;);
   */
  function filter(array, callback, thisArg) {
    var result;

    if (callback == &#x27;successful&#x27;) {
      // callback to exclude those that are errored, unrun, or have hz of Infinity
      callback = function(bench) { return bench.cycles &amp;&amp; isFinite(bench.hz); };
    }
    else if (callback == &#x27;fastest&#x27; || callback == &#x27;slowest&#x27;) {
      // get successful, sort by period + margin of error, and filter fastest/slowest
      result = filter(array, &#x27;successful&#x27;).sort(function(a, b) {
        a = a.stats; b = b.stats;
        return (a.mean + a.moe &gt; b.mean + b.moe ? 1 : -1) * (callback == &#x27;fastest&#x27; ? 1 : -1);
      });
      result = filter(result, function(bench) {
        return result[0].compare(bench) == 0;
      });
    }
    return result || reduce(array, function(result, value, index) {
      return callback.call(thisArg, value, index, array) ? (result.push(value), result) : result;
    }, []);
  }

  /**
   * A generic &#x60;Array#forEach&#x60; like method.
   * Callbacks may terminate the loop by explicitly returning &#x60;false&#x60;.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the callback.
   * @returns {Array} Returns the array iterated over.
   */
  function forEach(array, callback, thisArg) {
    var index = -1,
        length = (array = Object(array)).length &gt;&gt;&gt; 0;

    if (thisArg !== undefined) {
      callback = bind(callback, thisArg);
    }
    while (++index &lt; length) {
      if (index in array &amp;&amp;
          callback(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * Iterates over an object&#x27;s own properties, executing the &#x60;callback&#x60; for each.
   * Callbacks may terminate the loop by explicitly returning &#x60;false&#x60;.
   *
   * @static
   * @memberOf Benchmark
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the callback.
   * @returns {Object} Returns the object iterated over.
   */
  function forOwn(object, callback, thisArg) {
    return forProps(object, callback, { &#x27;bind&#x27;: thisArg, &#x27;which&#x27;: &#x27;own&#x27; });
  }

  /**
   * Converts a number to a more readable comma-separated string representation.
   *
   * @static
   * @memberOf Benchmark
   * @param {Number} number The number to convert.
   * @returns {String} The more readable string representation.
   */
  function formatNumber(number) {
    number = String(number).split(&#x27;.&#x27;);
    return number[0].replace(/(?=(?:\d{3})+$)(?!\b)/g, &#x27;,&#x27;) +
      (number[1] ? &#x27;.&#x27; + number[1] : &#x27;&#x27;);
  }

  /**
   * Checks if an object has the specified key as a direct property.
   *
   * @static
   * @memberOf Benchmark
   * @param {Object} object The object to check.
   * @param {String} key The key to check for.
   * @returns {Boolean} Returns &#x60;true&#x60; if key is a direct property, else &#x60;false&#x60;.
   */
  function hasKey() {
    // lazy define for worst case fallback (not as accurate)
    hasKey = function(object, key) {
      var parent = object != null &amp;&amp; (object.constructor || Object).prototype;
      return !!parent &amp;&amp; key in Object(object) &amp;&amp; !(key in parent &amp;&amp; object[key] === parent[key]);
    };
    // for modern browsers
    if (isClassOf(hasOwnProperty, &#x27;Function&#x27;)) {
      hasKey = function(object, key) {
        return object != null &amp;&amp; hasOwnProperty.call(object, key);
      };
    }
    // for Safari 2
    else if ({}.__proto__ == Object.prototype) {
      hasKey = function(object, key) {
        var result = false;
        if (object != null) {
          object = Object(object);
          object.__proto__ = [object.__proto__, object.__proto__ = null, result = key in object][0];
        }
        return result;
      };
    }
    return hasKey.apply(this, arguments);
  }

  /**
   * A generic &#x60;Array#indexOf&#x60; like method.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=0] The index to start searching from.
   * @returns {Number} The index of the matched value or &#x60;-1&#x60;.
   */
  function indexOf(array, value, fromIndex) {
    var index = toInteger(fromIndex),
        length = (array = Object(array)).length &gt;&gt;&gt; 0;

    index = (index &lt; 0 ? max(0, length + index) : index) - 1;
    while (++index &lt; length) {
      if (index in array &amp;&amp; value === array[index]) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Modify a string by replacing named tokens with matching object property values.
   *
   * @static
   * @memberOf Benchmark
   * @param {String} string The string to modify.
   * @param {Object} object The template object.
   * @returns {String} The modified string.
   */
  function interpolate(string, object) {
    forOwn(object, function(value, key) {
      // escape regexp special characters in &#x60;key&#x60;
      string = string.replace(RegExp(&#x27;#\\{&#x27; + key.replace(/([.*+?^=!:${}()|[\]\/\\])/g, &#x27;\\$1&#x27;) + &#x27;\\}&#x27;, &#x27;g&#x27;), value);
    });
    return string;
  }

  /**
   * Invokes a method on all items in an array.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} benches Array of benchmarks to iterate over.
   * @param {String|Object} name The name of the method to invoke OR options object.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
   * @returns {Array} A new array of values returned from each method invoked.
   * @example
   *
   * // invoke &#x60;reset&#x60; on all benchmarks
   * Benchmark.invoke(benches, &#x27;reset&#x27;);
   *
   * // invoke &#x60;emit&#x60; with arguments
   * Benchmark.invoke(benches, &#x27;emit&#x27;, &#x27;complete&#x27;, listener);
   *
   * // invoke &#x60;run(true)&#x60;, treat benchmarks as a queue, and register invoke callbacks
   * Benchmark.invoke(benches, {
   *
   *   // invoke the &#x60;run&#x60; method
   *   &#x27;name&#x27;: &#x27;run&#x27;,
   *
   *   // pass a single argument
   *   &#x27;args&#x27;: true,
   *
   *   // treat as queue, removing benchmarks from front of &#x60;benches&#x60; until empty
   *   &#x27;queued&#x27;: true,
   *
   *   // called before any benchmarks have been invoked.
   *   &#x27;onStart&#x27;: onStart,
   *
   *   // called between invoking benchmarks
   *   &#x27;onCycle&#x27;: onCycle,
   *
   *   // called after all benchmarks have been invoked.
   *   &#x27;onComplete&#x27;: onComplete
   * });
   */
  function invoke(benches, name) {
    var args,
        bench,
        queued,
        index = -1,
        eventProps = { &#x27;currentTarget&#x27;: benches },
        options = { &#x27;onStart&#x27;: noop, &#x27;onCycle&#x27;: noop, &#x27;onComplete&#x27;: noop },
        result = map(benches, function(bench) { return bench; });

    /**
     * Invokes the method of the current object and if synchronous, fetches the next.
     */
    function execute() {
      var listeners,
          async = isAsync(bench);

      if (async) {
        // use &#x60;getNext&#x60; as the first listener
        bench.on(&#x27;complete&#x27;, getNext);
        listeners = bench.events.complete;
        listeners.splice(0, 0, listeners.pop());
      }
      // execute method
      result[index] = isClassOf(bench &amp;&amp; bench[name], &#x27;Function&#x27;) ? bench[name].apply(bench, args) : undefined;
      // if synchronous return true until finished
      return !async &amp;&amp; getNext();
    }

    /**
     * Fetches the next bench or executes &#x60;onComplete&#x60; callback.
     */
    function getNext(event) {
      var cycleEvent,
          last = bench,
          async = isAsync(last);

      if (async) {
        last.off(&#x27;complete&#x27;, getNext);
        last.emit(&#x27;complete&#x27;);
      }
      // emit &quot;cycle&quot; event
      eventProps.type = &#x27;cycle&#x27;;
      eventProps.target = last;
      cycleEvent = Event(eventProps);
      options.onCycle.call(benches, cycleEvent);

      // choose next benchmark if not exiting early
      if (!cycleEvent.aborted &amp;&amp; raiseIndex() !== false) {
        bench = queued ? benches[0] : result[index];
        if (isAsync(bench)) {
          delay(bench, execute);
        }
        else if (async) {
          // resume execution if previously asynchronous but now synchronous
          while (execute()) { }
        }
        else {
          // continue synchronous execution
          return true;
        }
      } else {
        // emit &quot;complete&quot; event
        eventProps.type = &#x27;complete&#x27;;
        options.onComplete.call(benches, Event(eventProps));
      }
      // When used as a listener &#x60;event.aborted = true&#x60; will cancel the rest of
      // the &quot;complete&quot; listeners because they were already called above and when
      // used as part of &#x60;getNext&#x60; the &#x60;return false&#x60; will exit the execution while-loop.
      if (event) {
        event.aborted = true;
      } else {
        return false;
      }
    }

    /**
     * Checks if invoking &#x60;Benchmark#run&#x60; with asynchronous cycles.
     */
    function isAsync(object) {
      // avoid using &#x60;instanceof&#x60; here because of IE memory leak issues with host objects
      var async = args[0] &amp;&amp; args[0].async;
      return Object(object).constructor == Benchmark &amp;&amp; name == &#x27;run&#x27; &amp;&amp;
        ((async == null ? object.options.async : async) &amp;&amp; support.timeout || object.defer);
    }

    /**
     * Raises &#x60;index&#x60; to the next defined index or returns &#x60;false&#x60;.
     */
    function raiseIndex() {
      var length = result.length;
      if (queued) {
        // if queued remove the previous bench and subsequent skipped non-entries
        do {
          ++index &gt; 0 &amp;&amp; shift.call(benches);
        } while ((length = benches.length) &amp;&amp; !(&#x27;0&#x27; in benches));
      }
      else {
        while (++index &lt; length &amp;&amp; !(index in result)) { }
      }
      // if we reached the last index then return &#x60;false&#x60;
      return (queued ? length : index &lt; length) ? index : (index = false);
    }

    // juggle arguments
    if (isClassOf(name, &#x27;String&#x27;)) {
      // 2 arguments (array, name)
      args = slice.call(arguments, 2);
    } else {
      // 2 arguments (array, options)
      options = extend(options, name);
      name = options.name;
      args = isClassOf(args = &#x27;args&#x27; in options ? options.args : [], &#x27;Array&#x27;) ? args : [args];
      queued = options.queued;
    }

    // start iterating over the array
    if (raiseIndex() !== false) {
      // emit &quot;start&quot; event
      bench = result[index];
      eventProps.type = &#x27;start&#x27;;
      eventProps.target = bench;
      options.onStart.call(benches, Event(eventProps));

      // end early if the suite was aborted in an &quot;onStart&quot; listener
      if (benches.aborted &amp;&amp; benches.constructor == Suite &amp;&amp; name == &#x27;run&#x27;) {
        // emit &quot;cycle&quot; event
        eventProps.type = &#x27;cycle&#x27;;
        options.onCycle.call(benches, Event(eventProps));
        // emit &quot;complete&quot; event
        eventProps.type = &#x27;complete&#x27;;
        options.onComplete.call(benches, Event(eventProps));
      }
      // else start
      else {
        if (isAsync(bench)) {
          delay(bench, execute);
        } else {
          while (execute()) { }
        }
      }
    }
    return result;
  }

  /**
   * Creates a string of joined array values or object key-value pairs.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array|Object} object The object to operate on.
   * @param {String} [separator1=&#x27;,&#x27;] The separator used between key-value pairs.
   * @param {String} [separator2=&#x27;: &#x27;] The separator used between keys and values.
   * @returns {String} The joined result.
   */
  function join(object, separator1, separator2) {
    var result = [],
        length = (object = Object(object)).length,
        arrayLike = length === length &gt;&gt;&gt; 0;

    separator2 || (separator2 = &#x27;: &#x27;);
    each(object, function(value, key) {
      result.push(arrayLike ? value : key + separator2 + value);
    });
    return result.join(separator1 || &#x27;,&#x27;);
  }

  /**
   * A generic &#x60;Array#map&#x60; like method.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} thisArg The &#x60;this&#x60; binding for the callback.
   * @returns {Array} A new array of values returned by the callback.
   */
  function map(array, callback, thisArg) {
    return reduce(array, function(result, value, index) {
      result[index] = callback.call(thisArg, value, index, array);
      return result;
    }, Array(Object(array).length &gt;&gt;&gt; 0));
  }

  /**
   * Retrieves the value of a specified property from all items in an array.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {String} property The property to pluck.
   * @returns {Array} A new array of property values.
   */
  function pluck(array, property) {
    return map(array, function(object) {
      return object == null ? undefined : object[property];
    });
  }

  /**
   * A generic &#x60;Array#reduce&#x60; like method.
   *
   * @static
   * @memberOf Benchmark
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} accumulator Initial value of the accumulator.
   * @returns {Mixed} The accumulator.
   */
  function reduce(array, callback, accumulator) {
    var noaccum = arguments.length &lt; 3;
    forEach(array, function(value, index) {
      accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Aborts all benchmarks in the suite.
   *
   * @name abort
   * @memberOf Benchmark.Suite
   * @returns {Object} The suite instance.
   */
  function abortSuite() {
    var event,
        me = this,
        resetting = calledBy.resetSuite;

    if (me.running) {
      event = Event(&#x27;abort&#x27;);
      me.emit(event);
      if (!event.cancelled || resetting) {
        // avoid infinite recursion
        calledBy.abortSuite = true;
        me.reset();
        delete calledBy.abortSuite;

        if (!resetting) {
          me.aborted = true;
          invoke(me, &#x27;abort&#x27;);
        }
      }
    }
    return me;
  }

  /**
   * Adds a test to the benchmark suite.
   *
   * @memberOf Benchmark.Suite
   * @param {String} name A name to identify the benchmark.
   * @param {Function|String} fn The test to benchmark.
   * @param {Object} [options={}] Options object.
   * @returns {Object} The benchmark instance.
   * @example
   *
   * // basic usage
   * suite.add(fn);
   *
   * // or using a name first
   * suite.add(&#x27;foo&#x27;, fn);
   *
   * // or with options
   * suite.add(&#x27;foo&#x27;, fn, {
   *   &#x27;onCycle&#x27;: onCycle,
   *   &#x27;onComplete&#x27;: onComplete
   * });
   */
  function add(name, fn, options) {
    var me = this,
        bench = Benchmark(name, fn, options),
        event = Event({ &#x27;type&#x27;: &#x27;add&#x27;, &#x27;target&#x27;: bench });

    if (me.emit(event), !event.cancelled) {
      me.push(bench);
    }
    return me;
  }

  /**
   * Creates a new suite with cloned benchmarks.
   *
   * @name clone
   * @memberOf Benchmark.Suite
   * @param {Object} options Options object to overwrite cloned options.
   * @returns {Object} The new suite instance.
   */
  function cloneSuite(options) {
    var me = this,
        result = new me.constructor(extend({}, me.options, options));

    // copy own properties
    forOwn(me, function(value, key) {
      if (!hasKey(result, key)) {
        result[key] = value &amp;&amp; isClassOf(value.clone, &#x27;Function&#x27;)
          ? value.clone()
          : deepClone(value);
      }
    });
    return result;
  }

  /**
   * An &#x60;Array#filter&#x60; like method.
   *
   * @name filter
   * @memberOf Benchmark.Suite
   * @param {Function|String} callback The function/alias called per iteration.
   * @returns {Object} A new suite of benchmarks that passed callback filter.
   */
  function filterSuite(callback) {
    var me = this,
        result = new me.constructor;

    result.push.apply(result, filter(me, callback));
    return result;
  }

  /**
   * Resets all benchmarks in the suite.
   *
   * @name reset
   * @memberOf Benchmark.Suite
   * @returns {Object} The suite instance.
   */
  function resetSuite() {
    var event,
        me = this,
        aborting = calledBy.abortSuite;

    if (me.running &amp;&amp; !aborting) {
      // no worries, &#x60;resetSuite()&#x60; is called within &#x60;abortSuite()&#x60;
      calledBy.resetSuite = true;
      me.abort();
      delete calledBy.resetSuite;
    }
    // reset if the state has changed
    else if ((me.aborted || me.running) &amp;&amp;
        (me.emit(event = Event(&#x27;reset&#x27;)), !event.cancelled)) {
      me.running = false;
      if (!aborting) {
        invoke(me, &#x27;reset&#x27;);
      }
    }
    return me;
  }

  /**
   * Runs the suite.
   *
   * @name run
   * @memberOf Benchmark.Suite
   * @param {Object} [options={}] Options object.
   * @returns {Object} The suite instance.
   * @example
   *
   * // basic usage
   * suite.run();
   *
   * // or with options
   * suite.run({ &#x27;async&#x27;: true, &#x27;queued&#x27;: true });
   */
  function runSuite(options) {
    var me = this;

    me.reset();
    me.running = true;
    options || (options = {});

    invoke(me, {
      &#x27;name&#x27;: &#x27;run&#x27;,
      &#x27;args&#x27;: options,
      &#x27;queued&#x27;: options.queued,
      &#x27;onStart&#x27;: function(event) {
        me.emit(event);
      },
      &#x27;onCycle&#x27;: function(event) {
        var bench = event.target;
        if (bench.error) {
          me.emit({ &#x27;type&#x27;: &#x27;error&#x27;, &#x27;target&#x27;: bench });
        }
        me.emit(event);
        event.aborted = me.aborted;
      },
      &#x27;onComplete&#x27;: function(event) {
        me.running = false;
        me.emit(event);
      }
    });
    return me;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Executes all registered listeners of the specified event type.
   *
   * @memberOf Benchmark, Benchmark.Suite
   * @param {String|Object} type The event type or object.
   * @returns {Mixed} Returns the return value of the last listener executed.
   */
  function emit(type) {
    var listeners,
        me = this,
        event = Event(type),
        events = me.events,
        args = (arguments[0] = event, arguments);

    event.currentTarget || (event.currentTarget = me);
    event.target || (event.target = me);
    delete event.result;

    if (events &amp;&amp; (listeners = hasKey(events, event.type) &amp;&amp; events[event.type])) {
      forEach(listeners.slice(), function(listener) {
        if ((event.result = listener.apply(me, args)) === false) {
          event.cancelled = true;
        }
        return !event.aborted;
      });
    }
    return event.result;
  }

  /**
   * Returns an array of event listeners for a given type that can be manipulated
   * to add or remove listeners.
   *
   * @memberOf Benchmark, Benchmark.Suite
   * @param {String} type The event type.
   * @returns {Array} The listeners array.
   */
  function listeners(type) {
    var me = this,
        events = me.events || (me.events = {});

    return hasKey(events, type) ? events[type] : (events[type] = []);
  }

  /**
   * Unregisters a listener for the specified event type(s),
   * or unregisters all listeners for the specified event type(s),
   * or unregisters all listeners for all event types.
   *
   * @memberOf Benchmark, Benchmark.Suite
   * @param {String} [type] The event type.
   * @param {Function} [listener] The function to unregister.
   * @returns {Object} The benchmark instance.
   * @example
   *
   * // unregister a listener for an event type
   * bench.off(&#x27;cycle&#x27;, listener);
   *
   * // unregister a listener for multiple event types
   * bench.off(&#x27;start cycle&#x27;, listener);
   *
   * // unregister all listeners for an event type
   * bench.off(&#x27;cycle&#x27;);
   *
   * // unregister all listeners for multiple event types
   * bench.off(&#x27;start cycle complete&#x27;);
   *
   * // unregister all listeners for all event types
   * bench.off();
   */
  function off(type, listener) {
    var me = this,
        events = me.events;

    events &amp;&amp; each(type ? type.split(&#x27; &#x27;) : events, function(listeners, type) {
      var index;
      if (typeof listeners == &#x27;string&#x27;) {
        type = listeners;
        listeners = hasKey(events, type) &amp;&amp; events[type];
      }
      if (listeners) {
        if (listener) {
          index = indexOf(listeners, listener);
          if (index &gt; -1) {
            listeners.splice(index, 1);
          }
        } else {
          listeners.length = 0;
        }
      }
    });
    return me;
  }

  /**
   * Registers a listener for the specified event type(s).
   *
   * @memberOf Benchmark, Benchmark.Suite
   * @param {String} type The event type.
   * @param {Function} listener The function to register.
   * @returns {Object} The benchmark instance.
   * @example
   *
   * // register a listener for an event type
   * bench.on(&#x27;cycle&#x27;, listener);
   *
   * // register a listener for multiple event types
   * bench.on(&#x27;start cycle&#x27;, listener);
   */
  function on(type, listener) {
    var me = this,
        events = me.events || (me.events = {});

    forEach(type.split(&#x27; &#x27;), function(type) {
      (hasKey(events, type)
        ? events[type]
        : (events[type] = [])
      ).push(listener);
    });
    return me;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Aborts the benchmark without recording times.
   *
   * @memberOf Benchmark
   * @returns {Object} The benchmark instance.
   */
  function abort() {
    var event,
        me = this,
        resetting = calledBy.reset;

    if (me.running) {
      event = Event(&#x27;abort&#x27;);
      me.emit(event);
      if (!event.cancelled || resetting) {
        // avoid infinite recursion
        calledBy.abort = true;
        me.reset();
        delete calledBy.abort;

        if (support.timeout) {
          clearTimeout(me._timerId);
          delete me._timerId;
        }
        if (!resetting) {
          me.aborted = true;
          me.running = false;
        }
      }
    }
    return me;
  }

  /**
   * Creates a new benchmark using the same test and options.
   *
   * @memberOf Benchmark
   * @param {Object} options Options object to overwrite cloned options.
   * @returns {Object} The new benchmark instance.
   * @example
   *
   * var bizarro = bench.clone({
   *   &#x27;name&#x27;: &#x27;doppelganger&#x27;
   * });
   */
  function clone(options) {
    var me = this,
        result = new me.constructor(extend({}, me, options));

    // correct the &#x60;options&#x60; object
    result.options = extend({}, me.options, options);

    // copy own custom properties
    forOwn(me, function(value, key) {
      if (!hasKey(result, key)) {
        result[key] = deepClone(value);
      }
    });
    return result;
  }

  /**
   * Determines if a benchmark is faster than another.
   *
   * @memberOf Benchmark
   * @param {Object} other The benchmark to compare.
   * @returns {Number} Returns &#x60;-1&#x60; if slower, &#x60;1&#x60; if faster, and &#x60;0&#x60; if indeterminate.
   */
  function compare(other) {
    var critical,
        zStat,
        me = this,
        sample1 = me.stats.sample,
        sample2 = other.stats.sample,
        size1 = sample1.length,
        size2 = sample2.length,
        maxSize = max(size1, size2),
        minSize = min(size1, size2),
        u1 = getU(sample1, sample2),
        u2 = getU(sample2, sample1),
        u = min(u1, u2);

    function getScore(xA, sampleB) {
      return reduce(sampleB, function(total, xB) {
        return total + (xB &gt; xA ? 0 : xB &lt; xA ? 1 : 0.5);
      }, 0);
    }

    function getU(sampleA, sampleB) {
      return reduce(sampleA, function(total, xA) {
        return total + getScore(xA, sampleB);
      }, 0);
    }

    function getZ(u) {
      return (u - ((size1 * size2) / 2)) / sqrt((size1 * size2 * (size1 + size2 + 1)) / 12);
    }

    // exit early if comparing the same benchmark
    if (me == other) {
      return 0;
    }
    // reject the null hyphothesis the two samples come from the
    // same population (i.e. have the same median) if...
    if (size1 + size2 &gt; 30) {
      // ...the z-stat is greater than 1.96 or less than -1.96
      // http://www.statisticslectures.com/topics/mannwhitneyu/
      zStat = getZ(u);
      return abs(zStat) &gt; 1.96 ? (zStat &gt; 0 ? -1 : 1) : 0;
    }
    // ...the U value is less than or equal the critical U value
    // http://www.geoib.com/mann-whitney-u-test.html
    critical = maxSize &lt; 5 || minSize &lt; 3 ? 0 : uTable[maxSize][minSize - 3];
    return u &lt;= critical ? (u == u1 ? 1 : -1) : 0;
  }

  /**
   * Reset properties and abort if running.
   *
   * @memberOf Benchmark
   * @returns {Object} The benchmark instance.
   */
  function reset() {
    var data,
        event,
        me = this,
        index = 0,
        changes = { &#x27;length&#x27;: 0 },
        queue = { &#x27;length&#x27;: 0 };

    if (me.running &amp;&amp; !calledBy.abort) {
      // no worries, &#x60;reset()&#x60; is called within &#x60;abort()&#x60;
      calledBy.reset = true;
      me.abort();
      delete calledBy.reset;
    }
    else {
      // a non-recursive solution to check if properties have changed
      // http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4
      data = { &#x27;destination&#x27;: me, &#x27;source&#x27;: extend({}, me.constructor.prototype, me.options) };
      do {
        forOwn(data.source, function(value, key) {
          var changed,
              destination = data.destination,
              currValue = destination[key];

          if (value &amp;&amp; typeof value == &#x27;object&#x27;) {
            if (isClassOf(value, &#x27;Array&#x27;)) {
              // check if an array value has changed to a non-array value
              if (!isClassOf(currValue, &#x27;Array&#x27;)) {
                changed = currValue = [];
              }
              // or has changed its length
              if (currValue.length != value.length) {
                changed = currValue = currValue.slice(0, value.length);
                currValue.length = value.length;
              }
            }
            // check if an object has changed to a non-object value
            else if (!currValue || typeof currValue != &#x27;object&#x27;) {
              changed = currValue = {};
            }
            // register a changed object
            if (changed) {
              changes[changes.length++] = { &#x27;destination&#x27;: destination, &#x27;key&#x27;: key, &#x27;value&#x27;: currValue };
            }
            queue[queue.length++] = { &#x27;destination&#x27;: currValue, &#x27;source&#x27;: value };
          }
          // register a changed primitive
          else if (value !== currValue &amp;&amp; !(value == null || isClassOf(value, &#x27;Function&#x27;))) {
            changes[changes.length++] = { &#x27;destination&#x27;: destination, &#x27;key&#x27;: key, &#x27;value&#x27;: value };
          }
        });
      }
      while ((data = queue[index++]));

      // if changed emit the &#x60;reset&#x60; event and if it isn&#x27;t cancelled reset the benchmark
      if (changes.length &amp;&amp; (me.emit(event = Event(&#x27;reset&#x27;)), !event.cancelled)) {
        forEach(changes, function(data) {
          data.destination[data.key] = data.value;
        });
      }
    }
    return me;
  }

  /**
   * Displays relevant benchmark information when coerced to a string.
   *
   * @name toString
   * @memberOf Benchmark
   * @returns {String} A string representation of the benchmark instance.
   */
  function toStringBench() {
    var me = this,
        error = me.error,
        hz = me.hz,
        id = me.id,
        stats = me.stats,
        size = stats.sample.length,
        pm = support.java ? &#x27;+/-&#x27; : &#x27;\xb1&#x27;,
        result = me.name || (isNaN(id) ? id : &#x27;&lt;Test #&#x27; + id + &#x27;&gt;&#x27;);

    if (error) {
      result += &#x27;: &#x27; + join(error);
    } else {
      result += &#x27; x &#x27; + formatNumber(hz.toFixed(hz &lt; 100 ? 2 : 0)) + &#x27; ops/sec &#x27; + pm +
        stats.rme.toFixed(2) + &#x27;% (&#x27; + size + &#x27; run&#x27; + (size == 1 ? &#x27;&#x27; : &#x27;s&#x27;) + &#x27; sampled)&#x27;;
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Clocks the time taken to execute a test per cycle (secs).
   *
   * @private
   * @param {Object} bench The benchmark instance.
   * @returns {Number} The time taken.
   */
  function clock() {
    var applet,
        options = Benchmark.options,
        template = { &#x27;begin&#x27;: &#x27;s$=new n$&#x27;, &#x27;end&#x27;: &#x27;r$=(new n$-s$)/1e3&#x27;, &#x27;uid&#x27;: uid },
        timers = [{ &#x27;ns&#x27;: timer.ns, &#x27;res&#x27;: max(0.0015, getRes(&#x27;ms&#x27;)), &#x27;unit&#x27;: &#x27;ms&#x27; }];

    // lazy define for hi-res timers
    clock = function(clone) {
      var deferred;
      if (clone instanceof Deferred) {
        deferred = clone;
        clone = deferred.benchmark;
      }

      var bench = clone._original,
          fn = bench.fn,
          fnArg = deferred ? getFirstArgument(fn) || &#x27;deferred&#x27; : &#x27;&#x27;,
          stringable = isStringable(fn);

      var source = {
        &#x27;setup&#x27;: getSource(bench.setup, preprocess(&#x27;m$.setup()&#x27;)),
        &#x27;fn&#x27;: getSource(fn, preprocess(&#x27;f$(&#x27; + fnArg + &#x27;)&#x27;)),
        &#x27;fnArg&#x27;: fnArg,
        &#x27;teardown&#x27;: getSource(bench.teardown, preprocess(&#x27;m$.teardown()&#x27;))
      };

      var compiled = bench.compiled,
          count = bench.count = clone.count,
          decompilable = support.decompilation || stringable,
          id = bench.id,
          isEmpty = !(source.fn || stringable),
          name = bench.name || (typeof id == &#x27;number&#x27; ? &#x27;&lt;Test #&#x27; + id + &#x27;&gt;&#x27; : id),
          ns = timer.ns,
          result = 0;

      // init &#x60;minTime&#x60; if needed
      clone.minTime = bench.minTime || (bench.minTime = bench.options.minTime = options.minTime);

      // repair nanosecond timer
      // (some Chrome builds erase the &#x60;ns&#x60; variable after millions of executions)
      if (applet) {
        try {
          ns.nanoTime();
        } catch(e) {
          // use non-element to avoid issues with libs that augment them
          ns = timer.ns = new applet.Packages.nano;
        }
      }

      if (!compiled) {
        // compile in setup/teardown functions and the test loop
        compiled = bench.compiled = createFunction(preprocess(&#x27;t$&#x27;), interpolate(
          preprocess(deferred
            ? &#x27;var d$=this,#{fnArg}=d$,m$=d$.benchmark._original,f$=m$.fn,su$=m$.setup,td$=m$.teardown;&#x27; +
              // when &#x60;deferred.cycles&#x60; is &#x60;0&#x60; then...
              &#x27;if(!d$.cycles){&#x27; +
              // set &#x60;deferred.fn&#x60;
              &#x27;d$.fn=function(){var #{fnArg}=d$;if(typeof f$==&quot;function&quot;){try{#{fn}\n}catch(e$){f$(d$)}}else{#{fn}\n}};&#x27; +
              // set &#x60;deferred.teardown&#x60;
              &#x27;d$.teardown=function(){d$.cycles=0;if(typeof td$==&quot;function&quot;){try{#{teardown}\n}catch(e$){td$()}}else{#{teardown}\n}};&#x27; +
              // execute the benchmark&#x27;s &#x60;setup&#x60;
              &#x27;if(typeof su$==&quot;function&quot;){try{#{setup}\n}catch(e$){su$()}}else{#{setup}\n};&#x27; +
              // start timer
              &#x27;t$.start(d$);&#x27; +
              // execute &#x60;deferred.fn&#x60; and return a dummy object
              &#x27;}d$.fn();return{}&#x27;

            : &#x27;var r$,s$,m$=this,f$=m$.fn,i$=m$.count,n$=t$.ns;#{setup}\n#{begin};&#x27; +
              &#x27;while(i$--){#{fn}\n}#{end};#{teardown}\nreturn{elapsed:r$,uid:&quot;#{uid}&quot;}&#x27;),
          source
        ));

        try {
          if (isEmpty) {
            // Firefox may remove dead code from Function#toString results
            // http://bugzil.la/536085
            throw new Error(&#x27;The test &quot;&#x27; + name + &#x27;&quot; is empty. This may be the result of dead code removal.&#x27;);
          }
          else if (!deferred) {
            // pretest to determine if compiled code is exits early, usually by a
            // rogue &#x60;return&#x60; statement, by checking for a return object with the uid
            bench.count = 1;
            compiled = (compiled.call(bench, timer) || {}).uid == uid &amp;&amp; compiled;
            bench.count = count;
          }
        } catch(e) {
          compiled = null;
          clone.error = e || new Error(String(e));
          bench.count = count;
        }
        // fallback when a test exits early or errors during pretest
        if (decompilable &amp;&amp; !compiled &amp;&amp; !deferred &amp;&amp; !isEmpty) {
          compiled = createFunction(preprocess(&#x27;t$&#x27;), interpolate(
            preprocess(
              (clone.error &amp;&amp; !stringable
                ? &#x27;var r$,s$,m$=this,f$=m$.fn,i$=m$.count&#x27;
                : &#x27;function f$(){#{fn}\n}var r$,s$,m$=this,i$=m$.count&#x27;
              ) +
              &#x27;,n$=t$.ns;#{setup}\n#{begin};m$.f$=f$;while(i$--){m$.f$()}#{end};&#x27; +
              &#x27;delete m$.f$;#{teardown}\nreturn{elapsed:r$}&#x27;
            ),
            source
          ));

          try {
            // pretest one more time to check for errors
            bench.count = 1;
            compiled.call(bench, timer);
            bench.compiled = compiled;
            bench.count = count;
            delete clone.error;
          }
          catch(e) {
            bench.count = count;
            if (clone.error) {
              compiled = null;
            } else {
              bench.compiled = compiled;
              clone.error = e || new Error(String(e));
            }
          }
        }
      }
      // assign &#x60;compiled&#x60; to &#x60;clone&#x60; before calling in case a deferred benchmark
      // immediately calls &#x60;deferred.resolve()&#x60;
      clone.compiled = compiled;
      // if no errors run the full test loop
      if (!clone.error) {
        result = compiled.call(deferred || bench, timer).elapsed;
      }
      return result;
    };

    /*------------------------------------------------------------------------*/

    /**
     * Gets the current timer&#x27;s minimum resolution (secs).
     */
    function getRes(unit) {
      var measured,
          begin,
          count = 30,
          divisor = 1e3,
          ns = timer.ns,
          sample = [];

      // get average smallest measurable time
      while (count--) {
        if (unit == &#x27;us&#x27;) {
          divisor = 1e6;
          if (ns.stop) {
            ns.start();
            while (!(measured = ns.microseconds())) { }
          } else if (perfName) {
            divisor = 1e3;
            measured = Function(&#x27;n&#x27;, &#x27;var r,s=n.&#x27; + perfName + &#x27;();while(!(r=n.&#x27; + perfName + &#x27;()-s)){};return r&#x27;)(ns);
          } else {
            begin = ns();
            while (!(measured = ns() - begin)) { }
          }
        }
        else if (unit == &#x27;ns&#x27;) {
          divisor = 1e9;
          begin = ns.nanoTime();
          while (!(measured = ns.nanoTime() - begin)) { }
        }
        else {
          begin = new ns;
          while (!(measured = new ns - begin)) { }
        }
        // check for broken timers (nanoTime may have issues)
        // http://alivebutsleepy.srnet.cz/unreliable-system-nanotime/
        if (measured &gt; 0) {
          sample.push(measured);
        } else {
          sample.push(Infinity);
          break;
        }
      }
      // convert to seconds
      return getMean(sample) / divisor;
    }

    /**
     * Replaces all occurrences of &#x60;$&#x60; with a unique number and
     * template tokens with content.
     */
    function preprocess(code) {
      return interpolate(code, template).replace(/\$/g, /\d+/.exec(uid));
    }

    /*------------------------------------------------------------------------*/

    // detect nanosecond support from a Java applet
    each(doc &amp;&amp; doc.applets || [], function(element) {
      return !(timer.ns = applet = &#x27;nanoTime&#x27; in element &amp;&amp; element);
    });

    // check type in case Safari returns an object instead of a number
    try {
      if (typeof timer.ns.nanoTime() == &#x27;number&#x27;) {
        timers.push({ &#x27;ns&#x27;: timer.ns, &#x27;res&#x27;: getRes(&#x27;ns&#x27;), &#x27;unit&#x27;: &#x27;ns&#x27; });
      }
    } catch(e) { }

    // detect Chrome&#x27;s microsecond timer:
    // enable benchmarking via the --enable-benchmarking command
    // line switch in at least Chrome 7 to use chrome.Interval
    try {
      if ((timer.ns = new (window.chrome || window.chromium).Interval)) {
        timers.push({ &#x27;ns&#x27;: timer.ns, &#x27;res&#x27;: getRes(&#x27;us&#x27;), &#x27;unit&#x27;: &#x27;us&#x27; });
      }
    } catch(e) { }

    // detect &#x60;performance.now&#x60; microsecond resolution timer
    if ((timer.ns = perfName &amp;&amp; perfObject)) {
      timers.push({ &#x27;ns&#x27;: timer.ns, &#x27;res&#x27;: getRes(&#x27;us&#x27;), &#x27;unit&#x27;: &#x27;us&#x27; });
    }

    // detect Node&#x27;s microtime module:
    // npm install microtime
    if ((timer.ns = (req(&#x27;microtime&#x27;) || { &#x27;now&#x27;: 0 }).now)) {
      timers.push({ &#x27;ns&#x27;: timer.ns,  &#x27;res&#x27;: getRes(&#x27;us&#x27;), &#x27;unit&#x27;: &#x27;us&#x27; });
    }

    // pick timer with highest resolution
    timer = reduce(timers, function(timer, other) {
      return other.res &lt; timer.res ? other : timer;
    });

    // remove unused applet
    if (timer.unit != &#x27;ns&#x27; &amp;&amp; applet) {
      applet = destroyElement(applet);
    }
    // error if there are no working timers
    if (timer.res == Infinity) {
      throw new Error(&#x27;Benchmark.js was unable to find a working timer.&#x27;);
    }
    // use API of chosen timer
    if (timer.unit == &#x27;ns&#x27;) {
      extend(template, {
        &#x27;begin&#x27;: &#x27;s$=n$.nanoTime()&#x27;,
        &#x27;end&#x27;: &#x27;r$=(n$.nanoTime()-s$)/1e9&#x27;
      });
    }
    else if (timer.unit == &#x27;us&#x27;) {
      if (timer.ns.stop) {
        extend(template, {
          &#x27;begin&#x27;: &#x27;s$=n$.start()&#x27;,
          &#x27;end&#x27;: &#x27;r$=n$.microseconds()/1e6&#x27;
        });
      } else if (perfName) {
        extend(template, {
          &#x27;begin&#x27;: &#x27;s$=n$.&#x27; + perfName + &#x27;()&#x27;,
          &#x27;end&#x27;: &#x27;r$=(n$.&#x27; + perfName + &#x27;()-s$)/1e3&#x27;
        });
      } else {
        extend(template, {
          &#x27;begin&#x27;: &#x27;s$=n$()&#x27;,
          &#x27;end&#x27;: &#x27;r$=(n$()-s$)/1e6&#x27;
        });
      }
    }

    // define &#x60;timer&#x60; methods
    timer.start = createFunction(preprocess(&#x27;o$&#x27;),
      preprocess(&#x27;var n$=this.ns,#{begin};o$.elapsed=0;o$.timeStamp=s$&#x27;));

    timer.stop = createFunction(preprocess(&#x27;o$&#x27;),
      preprocess(&#x27;var n$=this.ns,s$=o$.timeStamp,#{end};o$.elapsed=r$&#x27;));

    // resolve time span required to achieve a percent uncertainty of at most 1%
    // http://spiff.rit.edu/classes/phys273/uncert/uncert.html
    options.minTime || (options.minTime = max(timer.res / 2 / 0.01, 0.05));
    return clock.apply(null, arguments);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Computes stats on benchmark results.
   *
   * @private
   * @param {Object} bench The benchmark instance.
   * @param {Object} options The options object.
   */
  function compute(bench, options) {
    options || (options = {});

    var async = options.async,
        elapsed = 0,
        initCount = bench.initCount,
        minSamples = bench.minSamples,
        queue = [],
        sample = bench.stats.sample;

    /**
     * Adds a number of clones to the queue.
     */
    function enqueue(count) {
      while (count--) {
        queue.push(bench.clone({
          &#x27;_original&#x27;: bench,
          &#x27;events&#x27;: {
            &#x27;abort&#x27;: [update],
            &#x27;cycle&#x27;: [update],
            &#x27;error&#x27;: [update],
            &#x27;start&#x27;: [update]
          }
        }));
      }
    }

    /**
     * Updates the clone/original benchmarks to keep their data in sync.
     */
    function update(event) {
      var clone = this,
          type = event.type;

      if (bench.running) {
        if (type == &#x27;start&#x27;) {
          // Note: &#x60;clone.minTime&#x60; prop is inited in &#x60;clock()&#x60;
          clone.count = bench.initCount;
        }
        else {
          if (type == &#x27;error&#x27;) {
            bench.error = clone.error;
          }
          if (type == &#x27;abort&#x27;) {
            bench.abort();
            bench.emit(&#x27;cycle&#x27;);
          } else {
            event.currentTarget = event.target = bench;
            bench.emit(event);
          }
        }
      } else if (bench.aborted) {
        // clear abort listeners to avoid triggering bench&#x27;s abort/cycle again
        clone.events.abort.length = 0;
        clone.abort();
      }
    }

    /**
     * Determines if more clones should be queued or if cycling should stop.
     */
    function evaluate(event) {
      var critical,
          df,
          mean,
          moe,
          rme,
          sd,
          sem,
          variance,
          clone = event.target,
          done = bench.aborted,
          now = +new Date,
          size = sample.push(clone.times.period),
          maxedOut = size &gt;= minSamples &amp;&amp; (elapsed += now - clone.times.timeStamp) / 1e3 &gt; bench.maxTime,
          times = bench.times,
          varOf = function(sum, x) { return sum + pow(x - mean, 2); };

      // exit early for aborted or unclockable tests
      if (done || clone.hz == Infinity) {
        maxedOut = !(size = sample.length = queue.length = 0);
      }

      if (!done) {
        // sample mean (estimate of the population mean)
        mean = getMean(sample);
        // sample variance (estimate of the population variance)
        variance = reduce(sample, varOf, 0) / (size - 1) || 0;
        // sample standard deviation (estimate of the population standard deviation)
        sd = sqrt(variance);
        // standard error of the mean (a.k.a. the standard deviation of the sampling distribution of the sample mean)
        sem = sd / sqrt(size);
        // degrees of freedom
        df = size - 1;
        // critical value
        critical = tTable[Math.round(df) || 1] || tTable.infinity;
        // margin of error
        moe = sem * critical;
        // relative margin of error
        rme = (moe / mean) * 100 || 0;

        extend(bench.stats, {
          &#x27;deviation&#x27;: sd,
          &#x27;mean&#x27;: mean,
          &#x27;moe&#x27;: moe,
          &#x27;rme&#x27;: rme,
          &#x27;sem&#x27;: sem,
          &#x27;variance&#x27;: variance
        });

        // Abort the cycle loop when the minimum sample size has been collected
        // and the elapsed time exceeds the maximum time allowed per benchmark.
        // We don&#x27;t count cycle delays toward the max time because delays may be
        // increased by browsers that clamp timeouts for inactive tabs.
        // https://developer.mozilla.org/en/window.setTimeout#Inactive_tabs
        if (maxedOut) {
          // reset the &#x60;initCount&#x60; in case the benchmark is rerun
          bench.initCount = initCount;
          bench.running = false;
          done = true;
          times.elapsed = (now - times.timeStamp) / 1e3;
        }
        if (bench.hz != Infinity) {
          bench.hz = 1 / mean;
          times.cycle = mean * bench.count;
          times.period = mean;
        }
      }
      // if time permits, increase sample size to reduce the margin of error
      if (queue.length &lt; 2 &amp;&amp; !maxedOut) {
        enqueue(1);
      }
      // abort the invoke cycle when done
      event.aborted = done;
    }

    // init queue and begin
    enqueue(minSamples);
    invoke(queue, {
      &#x27;name&#x27;: &#x27;run&#x27;,
      &#x27;args&#x27;: { &#x27;async&#x27;: async },
      &#x27;queued&#x27;: true,
      &#x27;onCycle&#x27;: evaluate,
      &#x27;onComplete&#x27;: function() { bench.emit(&#x27;complete&#x27;); }
    });
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Cycles a benchmark until a run &#x60;count&#x60; can be established.
   *
   * @private
   * @param {Object} clone The cloned benchmark instance.
   * @param {Object} options The options object.
   */
  function cycle(clone, options) {
    options || (options = {});

    var deferred;
    if (clone instanceof Deferred) {
      deferred = clone;
      clone = clone.benchmark;
    }

    var clocked,
        cycles,
        divisor,
        event,
        minTime,
        period,
        async = options.async,
        bench = clone._original,
        count = clone.count,
        times = clone.times;

    // continue, if not aborted between cycles
    if (clone.running) {
      // &#x60;minTime&#x60; is set to &#x60;Benchmark.options.minTime&#x60; in &#x60;clock()&#x60;
      cycles = ++clone.cycles;
      clocked = deferred ? deferred.elapsed : clock(clone);
      minTime = clone.minTime;

      if (cycles &gt; bench.cycles) {
        bench.cycles = cycles;
      }
      if (clone.error) {
        event = Event(&#x27;error&#x27;);
        event.message = clone.error;
        clone.emit(event);
        if (!event.cancelled) {
          clone.abort();
        }
      }
    }

    // continue, if not errored
    if (clone.running) {
      // time taken to complete last test cycle
      bench.times.cycle = times.cycle = clocked;
      // seconds per operation
      period = bench.times.period = times.period = clocked / count;
      // ops per second
      bench.hz = clone.hz = 1 / period;
      // avoid working our way up to this next time
      bench.initCount = clone.initCount = count;
      // do we need to do another cycle?
      clone.running = clocked &lt; minTime;

      if (clone.running) {
        // tests may clock at &#x60;0&#x60; when &#x60;initCount&#x60; is a small number,
        // to avoid that we set its count to something a bit higher
        if (!clocked &amp;&amp; (divisor = divisors[clone.cycles]) != null) {
          count = floor(4e6 / divisor);
        }
        // calculate how many more iterations it will take to achive the &#x60;minTime&#x60;
        if (count &lt;= clone.count) {
          count += Math.ceil((minTime - clocked) / period);
        }
        clone.running = count != Infinity;
      }
    }
    // should we exit early?
    event = Event(&#x27;cycle&#x27;);
    clone.emit(event);
    if (event.aborted) {
      clone.abort();
    }
    // figure out what to do next
    if (clone.running) {
      // start a new cycle
      clone.count = count;
      if (deferred) {
        clone.compiled.call(deferred, timer);
      } else if (async) {
        delay(clone, function() { cycle(clone, options); });
      } else {
        cycle(clone);
      }
    }
    else {
      // fix TraceMonkey bug associated with clock fallbacks
      // http://bugzil.la/509069
      if (support.browser) {
        runScript(uid + &#x27;=1;delete &#x27; + uid);
      }
      // done
      clone.emit(&#x27;complete&#x27;);
    }
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Runs the benchmark.
   *
   * @memberOf Benchmark
   * @param {Object} [options={}] Options object.
   * @returns {Object} The benchmark instance.
   * @example
   *
   * // basic usage
   * bench.run();
   *
   * // or with options
   * bench.run({ &#x27;async&#x27;: true });
   */
  function run(options) {
    var me = this,
        event = Event(&#x27;start&#x27;);

    // set &#x60;running&#x60; to &#x60;false&#x60; so &#x60;reset()&#x60; won&#x27;t call &#x60;abort()&#x60;
    me.running = false;
    me.reset();
    me.running = true;

    me.count = me.initCount;
    me.times.timeStamp = +new Date;
    me.emit(event);

    if (!event.cancelled) {
      options = { &#x27;async&#x27;: ((options = options &amp;&amp; options.async) == null ? me.async : options) &amp;&amp; support.timeout };

      // for clones created within &#x60;compute()&#x60;
      if (me._original) {
        if (me.defer) {
          Deferred(me);
        } else {
          cycle(me, options);
        }
      }
      // for original benchmarks
      else {
        compute(me, options);
      }
    }
    return me;
  }

  /*--------------------------------------------------------------------------*/

  // Firefox 1 erroneously defines variable and argument names of functions on
  // the function itself as non-configurable properties with &#x60;undefined&#x60; values.
  // The bugginess continues as the &#x60;Benchmark&#x60; constructor has an argument
  // named &#x60;options&#x60; and Firefox 1 will not assign a value to &#x60;Benchmark.options&#x60;,
  // making it non-writable in the process, unless it is the first property
  // assigned by for-in loop of &#x60;extend()&#x60;.
  extend(Benchmark, {

    /**
     * The default options copied by benchmark instances.
     *
     * @static
     * @memberOf Benchmark
     * @type Object
     */
    &#x27;options&#x27;: {

      /**
       * A flag to indicate that benchmark cycles will execute asynchronously
       * by default.
       *
       * @memberOf Benchmark.options
       * @type Boolean
       */
      &#x27;async&#x27;: false,

      /**
       * A flag to indicate that the benchmark clock is deferred.
       *
       * @memberOf Benchmark.options
       * @type Boolean
       */
      &#x27;defer&#x27;: false,

      /**
       * The delay between test cycles (secs).
       * @memberOf Benchmark.options
       * @type Number
       */
      &#x27;delay&#x27;: 0.005,

      /**
       * Displayed by Benchmark#toString when a &#x60;name&#x60; is not available
       * (auto-generated if absent).
       *
       * @memberOf Benchmark.options
       * @type String
       */
      &#x27;id&#x27;: undefined,

      /**
       * The default number of times to execute a test on a benchmark&#x27;s first cycle.
       *
       * @memberOf Benchmark.options
       * @type Number
       */
      &#x27;initCount&#x27;: 1,

      /**
       * The maximum time a benchmark is allowed to run before finishing (secs).
       * Note: Cycle delays aren&#x27;t counted toward the maximum time.
       *
       * @memberOf Benchmark.options
       * @type Number
       */
      &#x27;maxTime&#x27;: 5,

      /**
       * The minimum sample size required to perform statistical analysis.
       *
       * @memberOf Benchmark.options
       * @type Number
       */
      &#x27;minSamples&#x27;: 5,

      /**
       * The time needed to reduce the percent uncertainty of measurement to 1% (secs).
       *
       * @memberOf Benchmark.options
       * @type Number
       */
      &#x27;minTime&#x27;: 0,

      /**
       * The name of the benchmark.
       *
       * @memberOf Benchmark.options
       * @type String
       */
      &#x27;name&#x27;: undefined,

      /**
       * An event listener called when the benchmark is aborted.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onAbort&#x27;: undefined,

      /**
       * An event listener called when the benchmark completes running.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onComplete&#x27;: undefined,

      /**
       * An event listener called after each run cycle.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onCycle&#x27;: undefined,

      /**
       * An event listener called when a test errors.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onError&#x27;: undefined,

      /**
       * An event listener called when the benchmark is reset.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onReset&#x27;: undefined,

      /**
       * An event listener called when the benchmark starts running.
       *
       * @memberOf Benchmark.options
       * @type Function
       */
      &#x27;onStart&#x27;: undefined
    },

    /**
     * Platform object with properties describing things like browser name,
     * version, and operating system.
     *
     * @static
     * @memberOf Benchmark
     * @type Object
     */
    &#x27;platform&#x27;: req(&#x27;platform&#x27;) || window.platform || {

      /**
       * The platform description.
       *
       * @memberOf Benchmark.platform
       * @type String
       */
      &#x27;description&#x27;: window.navigator &amp;&amp; navigator.userAgent || null,

      /**
       * The name of the browser layout engine.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;layout&#x27;: null,

      /**
       * The name of the product hosting the browser.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;product&#x27;: null,

      /**
       * The name of the browser/environment.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;name&#x27;: null,

      /**
       * The name of the product&#x27;s manufacturer.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;manufacturer&#x27;: null,

      /**
       * The name of the operating system.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;os&#x27;: null,

      /**
       * The alpha/beta release indicator.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;prerelease&#x27;: null,

      /**
       * The browser/environment version.
       *
       * @memberOf Benchmark.platform
       * @type String|Null
       */
      &#x27;version&#x27;: null,

      /**
       * Return platform description when the platform object is coerced to a string.
       *
       * @memberOf Benchmark.platform
       * @type Function
       * @returns {String} The platform description.
       */
      &#x27;toString&#x27;: function() {
        return this.description || &#x27;&#x27;;
      }
    },

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf Benchmark
     * @type String
     */
    &#x27;version&#x27;: &#x27;1.0.0-pre&#x27;,

    // an object of environment/feature detection flags
    &#x27;support&#x27;: support,

    // clone objects
    &#x27;deepClone&#x27;: deepClone,

    // iteration utility
    &#x27;each&#x27;: each,

    // augment objects
    &#x27;extend&#x27;: extend,

    // generic Array#filter
    &#x27;filter&#x27;: filter,

    // generic Array#forEach
    &#x27;forEach&#x27;: forEach,

    // generic own property iteration utility
    &#x27;forOwn&#x27;: forOwn,

    // converts a number to a comma-separated string
    &#x27;formatNumber&#x27;: formatNumber,

    // generic Object#hasOwnProperty
    // (trigger hasKey&#x27;s lazy define before assigning it to Benchmark)
    &#x27;hasKey&#x27;: (hasKey(Benchmark, &#x27;&#x27;), hasKey),

    // generic Array#indexOf
    &#x27;indexOf&#x27;: indexOf,

    // template utility
    &#x27;interpolate&#x27;: interpolate,

    // invokes a method on each item in an array
    &#x27;invoke&#x27;: invoke,

    // generic Array#join for arrays and objects
    &#x27;join&#x27;: join,

    // generic Array#map
    &#x27;map&#x27;: map,

    // retrieves a property value from each item in an array
    &#x27;pluck&#x27;: pluck,

    // generic Array#reduce
    &#x27;reduce&#x27;: reduce
  });

  /*--------------------------------------------------------------------------*/

  extend(Benchmark.prototype, {

    /**
     * The number of times a test was executed.
     *
     * @memberOf Benchmark
     * @type Number
     */
    &#x27;count&#x27;: 0,

    /**
     * The number of cycles performed while benchmarking.
     *
     * @memberOf Benchmark
     * @type Number
     */
    &#x27;cycles&#x27;: 0,

    /**
     * The number of executions per second.
     *
     * @memberOf Benchmark
     * @type Number
     */
    &#x27;hz&#x27;: 0,

    /**
     * The compiled test function.
     *
     * @memberOf Benchmark
     * @type Function|String
     */
    &#x27;compiled&#x27;: undefined,

    /**
     * The error object if the test failed.
     *
     * @memberOf Benchmark
     * @type Object
     */
    &#x27;error&#x27;: undefined,

    /**
     * The test to benchmark.
     *
     * @memberOf Benchmark
     * @type Function|String
     */
    &#x27;fn&#x27;: undefined,

    /**
     * A flag to indicate if the benchmark is aborted.
     *
     * @memberOf Benchmark
     * @type Boolean
     */
    &#x27;aborted&#x27;: false,

    /**
     * A flag to indicate if the benchmark is running.
     *
     * @memberOf Benchmark
     * @type Boolean
     */
    &#x27;running&#x27;: false,

    /**
     * Compiled into the test and executed immediately **before** the test loop.
     *
     * @memberOf Benchmark
     * @type Function|String
     * @example
     *
     * // basic usage
     * var bench = Benchmark({
     *   &#x27;setup&#x27;: function() {
     *     var c = this.count,
     *         element = document.getElementById(&#x27;container&#x27;);
     *     while (c--) {
     *       element.appendChild(document.createElement(&#x27;div&#x27;));
     *     }
     *   },
     *   &#x27;fn&#x27;: function() {
     *     element.removeChild(element.lastChild);
     *   }
     * });
     *
     * // compiles to something like:
     * var c = this.count,
     *     element = document.getElementById(&#x27;container&#x27;);
     * while (c--) {
     *   element.appendChild(document.createElement(&#x27;div&#x27;));
     * }
     * var start = new Date;
     * while (count--) {
     *   element.removeChild(element.lastChild);
     * }
     * var end = new Date - start;
     *
     * // or using strings
     * var bench = Benchmark({
     *   &#x27;setup&#x27;: &#x27;\
     *     var a = 0;\n\
     *     (function() {\n\
     *       (function() {\n\
     *         (function() {&#x27;,
     *   &#x27;fn&#x27;: &#x27;a += 1;&#x27;,
     *   &#x27;teardown&#x27;: &#x27;\
     *          }())\n\
     *        }())\n\
     *      }())&#x27;
     * });
     *
     * // compiles to something like:
     * var a = 0;
     * (function() {
     *   (function() {
     *     (function() {
     *       var start = new Date;
     *       while (count--) {
     *         a += 1;
     *       }
     *       var end = new Date - start;
     *     }())
     *   }())
     * }())
     */
    &#x27;setup&#x27;: noop,

    /**
     * Compiled into the test and executed immediately **after** the test loop.
     *
     * @memberOf Benchmark
     * @type Function|String
     */
    &#x27;teardown&#x27;: noop,

    /**
     * An object of stats including mean, margin or error, and standard deviation.
     *
     * @memberOf Benchmark
     * @type Object
     */
    &#x27;stats&#x27;: {

      /**
       * The margin of error.
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;moe&#x27;: 0,

      /**
       * The relative margin of error (expressed as a percentage of the mean).
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;rme&#x27;: 0,

      /**
       * The standard error of the mean.
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;sem&#x27;: 0,

      /**
       * The sample standard deviation.
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;deviation&#x27;: 0,

      /**
       * The sample arithmetic mean.
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;mean&#x27;: 0,

      /**
       * The array of sampled periods.
       *
       * @memberOf Benchmark#stats
       * @type Array
       */
      &#x27;sample&#x27;: [],

      /**
       * The sample variance.
       *
       * @memberOf Benchmark#stats
       * @type Number
       */
      &#x27;variance&#x27;: 0
    },

    /**
     * An object of timing data including cycle, elapsed, period, start, and stop.
     *
     * @memberOf Benchmark
     * @type Object
     */
    &#x27;times&#x27;: {

      /**
       * The time taken to complete the last cycle (secs).
       *
       * @memberOf Benchmark#times
       * @type Number
       */
      &#x27;cycle&#x27;: 0,

      /**
       * The time taken to complete the benchmark (secs).
       *
       * @memberOf Benchmark#times
       * @type Number
       */
      &#x27;elapsed&#x27;: 0,

      /**
       * The time taken to execute the test once (secs).
       *
       * @memberOf Benchmark#times
       * @type Number
       */
      &#x27;period&#x27;: 0,

      /**
       * A timestamp of when the benchmark started (ms).
       *
       * @memberOf Benchmark#times
       * @type Number
       */
      &#x27;timeStamp&#x27;: 0
    },

    // aborts benchmark (does not record times)
    &#x27;abort&#x27;: abort,

    // creates a new benchmark using the same test and options
    &#x27;clone&#x27;: clone,

    // compares benchmark&#x27;s hertz with another
    &#x27;compare&#x27;: compare,

    // executes listeners
    &#x27;emit&#x27;: emit,

    // get listeners
    &#x27;listeners&#x27;: listeners,

    // unregister listeners
    &#x27;off&#x27;: off,

    // register listeners
    &#x27;on&#x27;: on,

    // reset benchmark properties
    &#x27;reset&#x27;: reset,

    // runs the benchmark
    &#x27;run&#x27;: run,

    // pretty print benchmark info
    &#x27;toString&#x27;: toStringBench
  });

  /*--------------------------------------------------------------------------*/

  extend(Deferred.prototype, {

    /**
     * The deferred benchmark instance.
     *
     * @memberOf Benchmark.Deferred
     * @type Object
     */
    &#x27;benchmark&#x27;: null,

    /**
     * The number of deferred cycles performed while benchmarking.
     *
     * @memberOf Benchmark.Deferred
     * @type Number
     */
    &#x27;cycles&#x27;: 0,

    /**
     * The time taken to complete the deferred benchmark (secs).
     *
     * @memberOf Benchmark.Deferred
     * @type Number
     */
    &#x27;elapsed&#x27;: 0,

    /**
     * A timestamp of when the deferred benchmark started (ms).
     *
     * @memberOf Benchmark.Deferred
     * @type Number
     */
    &#x27;timeStamp&#x27;: 0,

    // cycles/completes the deferred benchmark
    &#x27;resolve&#x27;: resolve
  });

  /*--------------------------------------------------------------------------*/

  extend(Event.prototype, {

    /**
     * A flag to indicate if the emitters listener iteration is aborted.
     *
     * @memberOf Benchmark.Event
     * @type Boolean
     */
    &#x27;aborted&#x27;: false,

    /**
     * A flag to indicate if the default action is cancelled.
     *
     * @memberOf Benchmark.Event
     * @type Boolean
     */
    &#x27;cancelled&#x27;: false,

    /**
     * The object whose listeners are currently being processed.
     *
     * @memberOf Benchmark.Event
     * @type Object
     */
    &#x27;currentTarget&#x27;: undefined,

    /**
     * The return value of the last executed listener.
     *
     * @memberOf Benchmark.Event
     * @type Mixed
     */
    &#x27;result&#x27;: undefined,

    /**
     * The object to which the event was originally emitted.
     *
     * @memberOf Benchmark.Event
     * @type Object
     */
    &#x27;target&#x27;: undefined,

    /**
     * A timestamp of when the event was created (ms).
     *
     * @memberOf Benchmark.Event
     * @type Number
     */
    &#x27;timeStamp&#x27;: 0,

    /**
     * The event type.
     *
     * @memberOf Benchmark.Event
     * @type String
     */
    &#x27;type&#x27;: &#x27;&#x27;
  });

  /*--------------------------------------------------------------------------*/

  /**
   * The default options copied by suite instances.
   *
   * @static
   * @memberOf Benchmark.Suite
   * @type Object
   */
  Suite.options = {

    /**
     * The name of the suite.
     *
     * @memberOf Benchmark.Suite.options
     * @type String
     */
    &#x27;name&#x27;: undefined
  };

  /*--------------------------------------------------------------------------*/

  extend(Suite.prototype, {

    /**
     * The number of benchmarks in the suite.
     *
     * @memberOf Benchmark.Suite
     * @type Number
     */
    &#x27;length&#x27;: 0,

    /**
     * A flag to indicate if the suite is aborted.
     *
     * @memberOf Benchmark.Suite
     * @type Boolean
     */
    &#x27;aborted&#x27;: false,

    /**
     * A flag to indicate if the suite is running.
     *
     * @memberOf Benchmark.Suite
     * @type Boolean
     */
    &#x27;running&#x27;: false,

    /**
     * An &#x60;Array#forEach&#x60; like method.
     * Callbacks may terminate the loop by explicitly returning &#x60;false&#x60;.
     *
     * @memberOf Benchmark.Suite
     * @param {Function} callback The function called per iteration.
     * @returns {Object} The suite iterated over.
     */
    &#x27;forEach&#x27;: methodize(forEach),

    /**
     * An &#x60;Array#indexOf&#x60; like method.
     *
     * @memberOf Benchmark.Suite
     * @param {Mixed} value The value to search for.
     * @returns {Number} The index of the matched value or &#x60;-1&#x60;.
     */
    &#x27;indexOf&#x27;: methodize(indexOf),

    /**
     * Invokes a method on all benchmarks in the suite.
     *
     * @memberOf Benchmark.Suite
     * @param {String|Object} name The name of the method to invoke OR options object.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
     * @returns {Array} A new array of values returned from each method invoked.
     */
    &#x27;invoke&#x27;: methodize(invoke),

    /**
     * Converts the suite of benchmarks to a string.
     *
     * @memberOf Benchmark.Suite
     * @param {String} [separator=&#x27;,&#x27;] A string to separate each element of the array.
     * @returns {String} The string.
     */
    &#x27;join&#x27;: [].join,

    /**
     * An &#x60;Array#map&#x60; like method.
     *
     * @memberOf Benchmark.Suite
     * @param {Function} callback The function called per iteration.
     * @returns {Array} A new array of values returned by the callback.
     */
    &#x27;map&#x27;: methodize(map),

    /**
     * Retrieves the value of a specified property from all benchmarks in the suite.
     *
     * @memberOf Benchmark.Suite
     * @param {String} property The property to pluck.
     * @returns {Array} A new array of property values.
     */
    &#x27;pluck&#x27;: methodize(pluck),

    /**
     * Removes the last benchmark from the suite and returns it.
     *
     * @memberOf Benchmark.Suite
     * @returns {Mixed} The removed benchmark.
     */
    &#x27;pop&#x27;: [].pop,

    /**
     * Appends benchmarks to the suite.
     *
     * @memberOf Benchmark.Suite
     * @returns {Number} The suite&#x27;s new length.
     */
    &#x27;push&#x27;: [].push,

    /**
     * Sorts the benchmarks of the suite.
     *
     * @memberOf Benchmark.Suite
     * @param {Function} [compareFn=null] A function that defines the sort order.
     * @returns {Object} The sorted suite.
     */
    &#x27;sort&#x27;: [].sort,

    /**
     * An &#x60;Array#reduce&#x60; like method.
     *
     * @memberOf Benchmark.Suite
     * @param {Function} callback The function called per iteration.
     * @param {Mixed} accumulator Initial value of the accumulator.
     * @returns {Mixed} The accumulator.
     */
    &#x27;reduce&#x27;: methodize(reduce),

    // aborts all benchmarks in the suite
    &#x27;abort&#x27;: abortSuite,

    // adds a benchmark to the suite
    &#x27;add&#x27;: add,

    // creates a new suite with cloned benchmarks
    &#x27;clone&#x27;: cloneSuite,

    // executes listeners of a specified type
    &#x27;emit&#x27;: emit,

    // creates a new suite of filtered benchmarks
    &#x27;filter&#x27;: filterSuite,

    // get listeners
    &#x27;listeners&#x27;: listeners,

    // unregister listeners
    &#x27;off&#x27;: off,

   // register listeners
    &#x27;on&#x27;: on,

    // resets all benchmarks in the suite
    &#x27;reset&#x27;: resetSuite,

    // runs all benchmarks in the suite
    &#x27;run&#x27;: runSuite,

    // array methods
    &#x27;concat&#x27;: concat,

    &#x27;reverse&#x27;: reverse,

    &#x27;shift&#x27;: shift,

    &#x27;slice&#x27;: slice,

    &#x27;splice&#x27;: splice,

    &#x27;unshift&#x27;: unshift
  });

  /*--------------------------------------------------------------------------*/

  // expose Deferred, Event and Suite
  extend(Benchmark, {
    &#x27;Deferred&#x27;: Deferred,
    &#x27;Event&#x27;: Event,
    &#x27;Suite&#x27;: Suite
  });

  // expose Benchmark
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if (typeof define == &#x27;function&#x27; &amp;&amp; typeof define.amd == &#x27;object&#x27; &amp;&amp; define.amd) {
    // define as an anonymous module so, through path mapping, it can be aliased
    define(function() {
      return Benchmark;
    });
  }
  // check for &#x60;exports&#x60; after &#x60;define&#x60; in case a build optimizer adds an &#x60;exports&#x60; object
  else if (freeExports) {
    // in Node.js or RingoJS v0.8.0+
    if (typeof module == &#x27;object&#x27; &amp;&amp; module &amp;&amp; module.exports == freeExports) {
      (module.exports = Benchmark).Benchmark = Benchmark;
    }
    // in Narwhal or RingoJS v0.7.0-
    else {
      freeExports.Benchmark = Benchmark;
    }
  }
  // in a browser or Rhino
  else {
    // use square bracket notation so Closure Compiler won&#x27;t munge &#x60;Benchmark&#x60;
    // http://code.google.com/closure/compiler/docs/api-tutorial3.html#export
    window[&#x27;Benchmark&#x27;] = Benchmark;
  }

  // trigger clock&#x27;s lazy define early to avoid a security error
  if (support.air) {
    clock({ &#x27;_original&#x27;: { &#x27;fn&#x27;: noop, &#x27;count&#x27;: 1, &#x27;options&#x27;: {} } });
  }
}(this));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
